[{"categories":["Life","Summary"],"contents":" 前言 十九年读书生涯已近尾声，不知不觉间已经走了很远了，从乡镇小学到现在211硕士毕业，偶尔回望过去，只觉得侥幸能苟延残喘到现在。 想来无论如何也不会有下一次毕业了，正值硕士毕业在即，不妨留下点所思所感用以回忆。\n考研 2021年9月，彼时刚打完比赛不久，还在不大积极地准备考研，日日图书馆枯坐，但也没有好好准备。 印象中到9月也没看完任何一门科目，嘴上说着想跨考计算机，其实也知道按照当时的那种进度真考了408肯定也是死路一条。 备考阶段我连哪个学校都没想好，更没想好为什么要读研究生，只是别人这样做了我就这样做而已。 当时也没这么想继续读研，反而是在原地迷茫，不知道该工作还是该继续读书。\n其实想想如果能更早的规划也不至于如此被动，无论是考研还是工作都应该更早确定。 别人要么考研要么工作，我还做比赛，结果比赛也g了，现在想想完全是脑残行为，摇摆不定只会害了自己。\n保研 学校的保研加分政策限制只能基于绩点排名前进4名，但估算了下自己的绩点、排名和名额，即使有加分项也深感保研无望。 我一向悲观，预估一件事没有希望后就会彻底躺平，连申请表都不想交上去，想着全力梭哈考研，好歹都会有书读。\n但感恩前女友没有放弃，不断push我提交了申请表，还帮我算我自己都懒得看一眼的权重计算公式让我提高信心。 印象中那段时间还在冷战，微信都删了，居然还发短信给我，虽然忘了她当时说了啥，但好像是鼓励的话，再次感恩。 结果的确让人惊喜，前面的同学或走其他升学计划、或放弃保研，正好让我踩到了末尾，侥幸拿到了保研资格。 其实还得再感恩她一次，如果不是每天在图书馆约会，或许我的绩点会更烂。\n翻看过去的推特，突然想起当时另外一个同学确定保研后甚至想卖考研资料给我。（低情商😭，我保上了都是送给室友的）\n侥幸拿到名额也只是后来痛苦的开端，但起初的那几个月的确是我人生中最舒适的阶段之一。 室友为了给我安利游戏送了我泰拉瑞亚，以前从没想过一个游戏能有如此好玩，于是和室友一起疯狂开黑。 后来室友也弃坑了，我还是一个人探索游戏里的世界，如此每天坐在电脑前12个小时，不断攻克BOSS，体验不同的职业和模组，偶尔和俩一同保研的朋友出门逛逛，随处探探店，江滩吹吹风，只觉得人生快乐莫过于此了。\n我永远怀念这一段时光。\n小小里程碑 至此就完成了本科的生活，本科过的痛并快乐着，被毒打过很多次，但我想这其中经历了很多有趣的事情。 回顾本科这几年，最让我痛恨的就是早操，不知道是哪个老登一拍脑门想出来的，每天大清早起床简直是反人类，除了吃个早饭给食堂送点钱实在是没有其他意义了。 相比之下，八人间上下床反而可以忍受，好歹碰到的室友磨合后都还不错。\n早期像只没开智的猴子一样得过且过，侥幸大二一些课程考的尚可，因此被俩同学z和l邀请打比赛。 但我当时没有什么电赛技能，也不会包装自己，参加比赛的面试自然是没有通过，还好他们俩给老师求情，给了我一个机会。 那时才知道原来事情还能这么干，还是得主动出击。 从他们身上我学到了很多品质，与z臭味相投，至今仍有联系，希望还能保持更久。 不得不提他教我机场，让我打开新世界的大门，哥们招数和执行力都让人叹为观止。 虽然因为一些弯弯绕绕还是和他们各自走上不同的道路，但着实还是感恩的，如果不是他们拉我打比赛，我或许会过得虚度光阴。 偶尔想想，那天才是真正的转折点。\n抛开功利，做比赛的体验还是非常美妙的，无论是前期准备，还是真正打比赛，都能锻炼解决问题的能力，哪怕失败也可以接受。 但开心不是比什么都重要的，事情也没有这么纯粹，那时候大家想拿个国奖证明自己的欲望达到了巅峰，最终就导致很多次几乎让人心态爆炸，但也只能向内归因是自己的准备不够，结果总是差一点。 好在数学建模和电赛打的多了也算圆满了，如图所示。 竞赛奖项 导师与矿山 本科学的一直是嵌入式相关，写的代码要与底层的硬件做交互，见识到了很多奇怪的bug和电容鞭炮的威力，而且每次焊电路闻着锡烟都感觉头昏脑胀，十分害怕英年早逝。 依照学长学姐们的升学出路，嵌入式读研能转的要么搞CV、要么就是更无聊的仪器，炼丹和调试恶心的电路相比之下，单纯敲码/冰镇可乐更痛快。 综合决定彻底转行纯软，于是在本校选了一个计算机学院跳槽过来的名声在外的导师。\n拿到名额的第二天就发去了邮件，实际上舔的更早，可惜当初不确定能否保研，于是就没了下文，朋友们都戏称我舔狗，的确具备舔狗天赋。 导师看到邮件后让我速速前往他的办公室沟通，没想到走上来就给我画了一张大饼，说项目组课题丰富，选择自由，但他更推荐智慧矿山，正好有个子系统没人做，不如小伙子你来做吧。 对于课题我也没什么选择依据，只能不断点头连连称是，稀里糊涂地接手了相伴四年的课题，当时也已经隐隐有了不妙的预感，毕竟名字里面带智慧的东西一般都不怎么样。\n当然最终还是不出意料顺利地进入了课题组（项目组），本科三年彻底结束，提前一年开始痛苦的四年牛马生涯。 从为人上来看，导师称得上是个好人，不抢一作，也不怎么PUA，实验室打卡也相当弹性，唯一的缺点就是不太懂得平衡自己与手下学生的诉求，一味想做成项目导致所有人都很痛苦。\n研0的时候就被导师要求用实验室自研C++框架写一个优化算法作为本科毕业设计，但不巧的是我既不了解框架也不懂优化算法，更痛苦的是框架没有文档，只能通过不断调试的方式了解框架。 现在想想反而觉得有意思，原以为复杂的东西仔细看看也没有想象那么难，这段经历很大程度上帮助我建立了信心，毕竟之前做的东西大多不成体系，写再多拿一个main就开跑的例子于自己无益。\n印象中那一阵每天都跟朋友抱怨，周周既要开会，又要汇报，还得挨骂，我一个研0的我懂什么。 抱怨归抱怨，活还是得干，一边恶补C++，一边学优化算法，框架里实在不懂的东西只能厚着脸皮问实验室的师兄，好在比赛做多了倒也习惯了这种苦逼日子，但这只是开胃菜。\n按照导师的规划，建立一个完整的矿山子系统，仅需要的技术栈就有C++、CMake、Java、SpringBoot、Vue2、Qt5、MySQL等，更不用说开发工具、设计模式、数据结构、优化算法等知识，而我当时仅仅会C、Python、MATLAB和一些用不上的嵌入式知识。\n于是我的第一课就是开始各种恶补，当时每天都倍速猛看各种技术教程，为黑马程序员、尚硅谷等各种机构贡献了不少硬币，感恩他们，不愧是培训班，教的的确快。 那一阵子每天睁眼就是学，好在有本科比赛经历的磨练，我很快适应了这种节奏并乐在其中，学到的任何东西都能在项目里快速实践练手，对个人的正反馈非常之及时，而且恰好符合我自己的兴趣，不仅不觉得苦，反而觉得很有挑战。 其实很多概念本质都很简单，只是被各种神乎其神的技术名词隐藏了容易理解的本质，当然不得不吐槽前端技术是真的杂。 项目中间出现过相当多的各种各样的技术问题，诸如为什么Java调用动态链接库会发生内存泄漏、为什么CMake老是找不到依赖库、如何让算法跑得更快、如何让Java调用C++的时候也能调试等等。 当时没有GPT，只能硬着头皮从各种中英文论坛、博客、官网文档去找不同解决方案，实践过程就像解一个个谜题，更让人感觉上瘾。 时常感叹这些奇妙想法之上的造物简直是艺术，并为之着迷，但更多的是其实只是好奇。\n虽然项目的技术多，但却也有限，一年半左右我已经掌握了项目中几乎的所有技术栈，正如游戏通关，我很难再从项目中汲取正反馈了。 后来我把目标转向更底层一些的计算机技术，并给自己定下了一些学习主题，比如操作系统、数据库、编译原理、分布式等，当然也没什么特别好的招，只能看看国外的公开课跟着做lab。 无奈的是项目每周都需要开会汇报进度，紧急的时候甚至需要日报，让我不得不优先完成项目的需求。\n其实功能已经开发完了，每次开会就是表演系统运行，点点按钮，听下甲方和导师的反馈意见再去调调表格宽度、主题色彩这种很无聊的事情。 偶尔自我宽慰这些事情或许有某种意义，但想来想去也觉得是自欺欺人，大一点小一点又能怎么样呢？ 无非是没有设计师和产品经理，只好把“五彩斑斓的黑”翻来覆去地讲。\n那阵子是我最痛苦的时光，我也会永远铭记，给我的教训就是不要做无意义的事情。\n双管齐下难免分心，我相当忌讳这种感觉，一旦发觉自己处于这种“并发”的情况，就必须要剔除不重要的部分，只好延期原有学习计划。 除了项目外，当然还会有些课题上的事情终究避不开，最终花了四五个月也只完成了一项操作系统的学习。 不过值得一提的是花大把时间阅读几万行的源码也让我深刻理解了一个mini操作系统的原理，的确很有趣，此事在之前的博客中亦有记载😊。\n23年年末，突然被隔壁组同学告知导师要跳槽，消息来源居然是贴吧的帖子，求证之后只觉得难以接受。 一方面导师居然瞒着自己的学生一个人跑路，做事不地道，另一方面则是迷茫，不知道未来应该何去何从。 怀揣着紧张的心情度过了一个月左右，导师总算跟我们摊牌了，不过也只是事后通知，聊来聊去让我们继续跟他干，他会帮助我们的。 回过头再看只有一种感受，如图所示。 项目开发接近尾声，导师又提桶跑路，那一阵子也是难得的闲暇时光，所以上面说四年牛马生涯倒也不太准确，其实只有两年半，最后一年发生的事在2024总结中亦有记载。\n补课 其实读研工资不高，特别干的还是一个没中标的项目，再加上导师抠门，僧多粥少，每月所有补助到手总共也只能到一千左右。 （中间实验室打游戏第二次被他抓到了又扣了我四百😭） 这种工资吃饭勉强够，但又不够偶尔享受下生活，不好意思向父母要，过得拮据只好自己想办法，好在同门介绍了一个补课的兼职。\n同门和我一起给一个学生补课，我俩间隔着去给他补课，同门教数学我教英语，上午嘴皮子一刻不停，每次回来都得睡一个下午，累得够呛，好在工资也有个一两百，也算有所回报。 拿人钱财总得替人办事，期间用了很多招来帮他提升英语，可补课间隔周期长，每次检查之前的学习情况又让人失望，只好带着再教一遍上一次的。 可跟这小子聊多了我才惊觉，这家伙不止这一门不行，而是没一门行的，父母只让他补数学和英语完全是无奈之举。 算了算每月两千左右的补课支出对普通家庭来说不是一个小数目，再多补几门就难以承担，但不补的话以当时的成绩连普通高中都是奢望。\n城市普通人家孩子都这样，乡下孩子就更不必说了。 上研究生后每次暑假回家大舅都会让我给两个表弟补课，大小表弟都在初中阶段，成绩都不算好，在如今的分流政策下大概率只能上职高。 大舅两口子在外工作勤勤恳恳，可还是忽视了孩子的教育，说实话给他们补课不亚于女娲补天。 小表弟还算可以，能勉强达到及格水准，可跟大表弟聊了后才发觉这小子更夸张，临近初三都不会四则运算，只好倒退回去讲讲小学的知识。 补课路上 也许是看到曾经的自己，哪怕在学校我也会抽空开个线上会议给他们补课，补完也会和他们聊聊读书的重要性，但看着他们不太想听只想打游戏的态度，常常自嘲自己也开始变得无聊。\n这么些年里，我遇到了很多优秀的人，让我印象深刻的是他们受教育程度往往和所在地区的发达情况关系较大，更准确来说是和家庭的经济情况正相关。 在高考前就有顶尖老师来教学，上了大学就能请到一个绝对足够优秀的前辈规划路线，避开所有坑点，可谓是站在巨人肩膀上。 而你却只能凭自己的直觉和努力来找方向，甚至大多数回归本性开始摆烂，这还怎么玩，难道不公平重赛？ 教育资源向来不均衡，况且家在乡下，周边的同学也大多浑浑噩噩整日游戏，父母难以托底，未来模糊不清，教育资源贫瘠，近年更是禁止老师补课，只能依赖一些高考结束后学生的爆金币补习班。 可哪怕有靠谱的老师又能怎么样呢？ 补几门还是全补？舍得掏出多少积蓄来补课？上了普高又能不能上个好大学？以后毕业怎么办，又能卷出头吗？ 这些都是未知数，在农村为人父母也少有心思能关心到这么长远，生存的压力都让人疲于奔命，只好是养而不育，赌一把孩子未来能开窍。 当然再延伸就是一些更深刻的问题，可世界上没有后悔药，还是得面对。\n我向来不给人提建议，既是没能力也往往吃力不讨好。 可大舅为人和善，踏实肯干，对生活积极乐观，这和我见过的大多数人都不一样，我由衷地希望他们能更好，所以想来想去还是谨慎地给了大舅一些建议。 我也想不出什么好招，只好劝他们看看送孩子出国这一条路，便宜点的国家读个硕士咬咬牙完全能顶住，稍微努力点也有出路。 但这些离他们太远，近在眼前的是名声上的体面。 拿出积蓄，背上贷款，咬咬牙上车去市里买套房，美其名曰为孩子着想，但至于表弟们的未来也只能靠自己，再加上命运的安排了。\n大表弟不出意料上了职高，小表弟已经接近中考，偶尔放假回家去看外公外婆都会被大舅留住，拜托我多和小表弟聊聊，让他能好好学习，不要重蹈覆辙。 可又能怎么样呢，看的越多越觉得能改变的太少，做错一步就只能白白浪费时间，况且也没有义务再做更多。 很多事情的决定因素不是其本身，而是在于其他东西。 根源从来不在小孩身上，而在于父母，往往只是向一个方向尝试努力一次，眼见没有效果就果断摆烂，只觉得孩子不是读书的料。 父母放弃了，孩子也更心安理得，至于以后的事情那就以后再说。\n从历史中不难看出，人很擅长催眠自己，曾经我的对很多事情的态度也是如此，但现在才知道这些都是自欺欺人。 不仅要多想多试，还必须要坚持，哪怕错过了时机。\n旅途的终点 在泰拉瑞亚打完月亮领主就到了旅途的终点，官方的内容到此为止，但可以下载三方模组，以体验更多内容，希望我也能如此。\n读研过的相当无聊，时常对着电脑敲码，闲暇之余畅想什么时候是个头，但真到了这一步反而怅然若失，以后又该怎么办？ 原本写这篇的初衷也是想谈谈这期间的感受，但恍惚间回忆如潮水般涌来，不知不觉写成了杂记。 这几年饱受折磨后人性深处的一些弥足珍贵的东西也逐渐被磨平，逐渐发现原来这个世界和我想的不太一样，看的越多越觉得善与恶、对与错的边界模糊不清，很多事情也难以言说，愈发觉得自己的渺小。 偶尔面对事物审视内心的想法，才发现某些曾经痛恨的东西不知不觉间已经和我融为一体，被裹挟久了更加沉重得无法摆脱。 其实还有很多相关经历和思考都想写下来，但想来想去也是自找麻烦，或许以后能落笔记录，或许也会被遗忘，未来的事谁又说的准呢。 之前常常在选择面前思考人生的意义是什么，可自己又不学无术，没读过几本书，思考太多反而带来更多痛苦。 现在反倒只想探索自我，追求内心的平静，不要白白浪费自己的一生。 当然最好多看一些书，多去一些地方🤗。\n这一路漫无目的地走来，有很多事情改变了我，也让我学到不少东西，但我想最重要的一课永远是：无论成为什么样的人，衡量成功的标尺只有一条——把握自己的命运。 End ","date":"2025-06-10T01:12:00+08:00","permalink":"https://o-a-p.github.io/post/year/2025-mid/","section":"post","tags":null,"title":"读研往事"},{"categories":["Life","Summary"],"contents":" 前言 转眼间又是一年，以前每年都看着大佬们分享自己年终总结，总是收获颇多，也许是见贤思齐，也许是附庸风雅，想着也试试总结自己的这一年，为以后提供一些回忆的流水账🙂。\n年初 大年三十晚上还和h、t三个人在镇上新建的篮球场坐着放烟花，没想到一年没怎么回家，连这样的偏僻小地方都建起了还算现代的公共设施。 不过看着旁边扬起灰尘的破旧道路还是有些割裂感，希望它的生命周期能延续久一点。\n即使是在这样难得的闲暇日子里，大家都被社会折磨得略显憔悴，一年未曾见面，彼此难免相顾无言，好在分享一年的糟心事和八卦后又找到了曾经的状态。 h叼着烟，左手打火机右手炮仗在篮球场肆意cos炸弹人，我点下了新年第一束烟花默默许愿自己能在今年找到一份好工作。\n或许是许愿起了效果，拿到的offer的确还不错，但所有命运馈赠的礼物，早已在暗中标好了价格，比如今年右肾里形成了一颗“金丹”，当然这只是后话。\n无意间瞥见坡上的火星倒是给t带来了点工作压力，不过看着姐们冷静摇人扑灭火星，不禁感叹真是相当熟悉业务的打工人了。和朋友们跨年+灭火算是相当难得的体验，但耐不住半夜寒风刺骨，看着老哥们灭完火便各自回了家。\n年后还和更多的朋友们相聚江边欣赏落日，拉通对齐彼此在过去一年的变化，总结下来就是大家都上岸工作了，只有我一个人还在苦逼地上学。\n大家都是年后几天就要去上班，美好的时光总是短暂，所以连聚了好几天。 几天下来都是由f开着车带着我们胡吃海喝看电影逛鬼屋，这倒不符合我的消费习惯，但好在朋友们颇为理解学生仔的囊中羞涩，让我吃饭没怎么花钱，只请大家喝了一杯便宜奶茶便算是回请了，在这里祝各位大哥大姐新年好了。 这里值得一提的是f的车技实在让人不敢恭维，突如其来的连续变道让我体验了人生第一次车祸，好在只是刮蹭，有车险也没有大出血，希望f能够好好反思🤬。\n返校 返校后就开始准备找工作的事情，去年师兄师姐们秋招的情形太过惨烈，让我不得不提前准备，每天都学得头昏脑胀，但未必事事都能得到一个满意的结果。\n在学校的一大乐事就是每天撸撸猫，遗憾的是最后见了橘桑一面，听说是被人领养了，虽然橘桑让我打了不少次狂犬疫苗，但还是祝福它幸福吧。\n五一去深圳玩了些日子，借住在亲戚家，亲戚刚好有空，便带着我随处逛了逛。 只能说不愧是一线城市，各种供给市民休闲娱乐的基础设施的确让人叹为观止。 城市路面也相当干净，建筑各有特色，气候不冷不热，比武汉这样的火炉待着的确舒服太多，不过这个灯光秀倒是非常一般，不如武汉江滩的灯光秀。\n对深圳最初的印象就是公园和图书馆相当之多，图书馆倒是没怎么去，但公园的确逛了不少，莲花山公园、人才公园、深圳湾公园都很不错，的确是放松休闲好去处，可惜就是房价不怎么宜居。 还在深圳看了早有耳闻的RoboMaster决赛，只能说不愧是别人家的比赛，比我参加过的电赛智能车不知道高到哪里去了。值得一提的是由于是大疆办的比赛，他们为搞比赛的学生专门提供了RoboMaster招聘通道，不过听朋友说也招不了多少人，不知道是真是假。\n本科看《中国梵高》的时候就对大芬产生了好奇，居然有一个地方把油画这种在人们印象中高大上的艺术做成了一笔一画复制粘贴的活计，还真在某种意义上让艺术走到群众中去。 当然到了大芬就必须去赵小勇工作室了，作为纪录片的主角，店里还是挂了不少梵高作品，听他介绍有不少是他老婆画的，他自己倒是创作了不少作品，好一个大芬之光。\n当然还有一些不错的展，但没怎么拍照，这里就不再写流水账了。\n暑假 暑假和朋友去了一趟南昌，这里就不再赘述。 暑假做的另一件事是为了发篇会议论文，天天熬夜到2点把课题的代码写的差不多了，好在最终论文也是被录用了，也算搞定了毕业条件。\n秋招 那么就进入正式发力的时候了，由于技术栈是C++，从8月份正式开始投简历。投递思路大概是互联网、自动驾驶、游戏后台以及客户端等几个方向。当然实际上也是海投，即使没有目标岗位，只要岗位的JD上有写C++就会投。截止到9月中旬总计投了106家，9月中旬拿到offer后基本就挑着笔/面了，总计面了12家，其中OC了4家，泡出来1家，被挂7家，口语不太好，所以也没有投啥外企，感觉亏了不少。\n总体体验下来，秋招的难度还行，最后综合还是选择了最心仪的公司，为此还拒绝了个超级大包。反思后，整个秋招过程里还是有几点需要注意：\n应该早点把简历改好直接开投，犹豫太久错过了提前批（当然学历也未必够，不过不试试怎么知道） 如果不是非常值得去，应该拒绝所有线下面试，成本太高昂了 回答八股要有清晰的叙述逻辑，内容尽量精简，并且带上自己的思考或者使用经验 反问阶段很重要，尽量在一听到业务后就能马上抛出一两个切中业务关键并且有价值的问题 虽然200道基本能覆盖面试中的题目，leetcode还得接着刷，保持手感 有offer就会有选择，任何事情都有代价，无论怎么选都会有小小的遗憾，毕竟人往往会美化另外一条没选的路。 追逐确定性就会丧失可能性，反之亦然，虽然还是患得患失，但很受用的一点是只关注自己得到的东西，而不是失去的东西，再把眼下的事情做得漂亮一点，一定程度上就可以消除这种烦恼。\n对我来说，找工作就像是在攀岩，面试轮次的增加意味着攀爬得更高，但伴随而来的则是脚下的悬崖显得愈加可怖，一旦跌落就要承受更多的痛苦。 这种感觉在秋招的过程中都困扰着我，让我彻夜难眠，我不确定自己是否已经克服它，也许以后还会再经历一次，但到那时应该更加游刃有余。\n青岛 这次去青岛住在会议酒店附近，机场的位置也是够偏，凌晨从机场出来坐上100码的黑车都跑了个把小时，还转了两趟黑车。 也没想到这地方离市中心这么远，去一趟市中心基本要坐2个小时的地铁，而且青岛地铁晚上10点停运，基本上每次回去都是赶不上转最后一段地铁只能打车回酒店。 会议期间刚好有LOL决赛可以看，看前几把还高高兴兴吃着小串，和同行老哥都觉得今年夺冠有望，熬夜看到第五把，越看越沉默，没想到BLG被faker杀穿了，只能说时也命也。\n由于历史原因，在逛完栈桥之后沿着地图走到教堂，一路上能见到不少颇有异域风情的建筑。不过要逛的地方太多，时间不等人，匆忙拍照打卡就溜到下一个景点了。\n也许是为了防止餐厅宰客，青岛有一个很有意思的做法：客人自己从海鲜市场买海鲜，交给啤酒屋加工，加工费由政府明码标价。 临走的前一天晚上也是尝试了一次，在海鲜市场有没有被坑不清楚，但可惜还是被啤酒屋小坑了一把，做的大龙虾非常难吃。\n海鲜的确是十分新鲜，生蚝便宜个儿又大，除了海肠拌饭和大龙虾不太好吃，其他都还算美味。 作为外地人，我对青岛的印象还停留在啤酒上，第一天过去喝了点果啤，心想就这，没想到当天晚上喝的原酿这么好喝，入口不像普通啤酒那么难喝，反而带了一点点香味，可惜酒精过敏，几杯下肚脸就红得不行。\n这一趟玩下来还是有些无聊，国内城市玩着都大同小异，以后还是选择露营登山或者出国作为旅游的选项。\n淮南 这时候想必我是该来了。\n今年导师跳槽到淮南的安徽理工大学，安排我们出差过来和师弟师妹们对接系统，聊聊课题。 武汉到淮南并没有直达的高铁，需要在合肥转车。到了淮南一出高铁站就好像回了老家，在陌生的地方也有了些奇怪的归属感。 出站打个车就去了学校，很是突兀地见到了新师弟师妹们，和他们同导异校多少有些同父异母的孩子初次见面的荒诞，但架不住实在热情，当晚吃饭来来回回敬酒起立不少次，一顿饭吃到了大半夜。 虽然态度十分热情，学习态度也很好，但其实技术上都没有怎么准备，所以很难说对接有多少效果。\n对接会议由师弟主持，师弟当主持人有模有样的，的确有一套。 非常值得一提的是师弟过去一趟俘获了一位师妹的芳心，临走时拎着师妹送的面包恋恋不舍，还不愿意分享，我的评价是乐不思蜀了。 这里应师弟强烈要求不P图，只能满足他了。\n导师跳槽能够理解，对于满腔抱负的人来说，去了安理这种全新的平台的确更有施展的空间。 对于我们而言是好是坏却很难确定，但至少平时的确自由多了，毕竟偶尔摸鱼不必担心背后刷新导师😋。\n游戏 今年依旧是LOL大乱斗养老的一年 抽空又N刷了一遍泰拉瑞亚，但毕竟游戏内容有限，折腾模组又觉得麻烦，已经对这个游戏有些审美疲劳了 受朋友安利购买骗子酒馆玩了玩，但感觉没啥意思，或许是我们人不够多的缘故，和路人玩总是玩不起来 史低入手了怪物猎人，手感和我想象中差别倒不太大，但游戏系统出乎意料的复杂，年底要交毕业论文了，只能忍忍（朋友推荐用手柄玩，下次一定试试） 其实今年在游戏上花的时间比较多，原因可能是学习八股太无聊，没有及时的正反馈，所以就痴迷网络游戏了，显然爱好成了必要的事情后也会让人痛苦。 沉迷LOL的确有些浪费时间，也获得不了啥新奇的体验，想想还是得卸载。 希望明年能够试试更多眼馋已久的游戏，比如说塞尔达、文明、无主之地等等，不再当乱斗养老哥。\n技术 今年有些偷懒没怎么做公开课，只完成了CSAPP的bomb lab和15445的Project1就歇菜了。大部分时间都在准备各种八股和刷题，如今想来还是有些浮躁，在技术上的积累基本是0，只能和别人吹吹牛，连静下心看代码的时间都很少，希望毕业之前能把欠下来的这些课都给啃完。\nC++用的倒是比较溜了，但对新特性了解还是不够好，每次看各种技术分享和别的老哥交流都能学到东西，还是比较菜。后面有空的话倒想把课题的代码尽可能实现好，毕竟也算一个C++项目。\n非科班出身还是有些影响，对于编译原理、分布式系统、图形学这些稍显硬核的技术了解是一片空白，好几次听到相关技术都有种“书到用时方恨少”的无奈。 其实归根结底都是认知上的差距，如果连方向都不知道，又何谈努力呢，以后至少要在编译原理和分布式系统投入时间系统学习一下。\nWeb开发好久没看，基本都忘光了，尽管比较半吊子，不过以后有用应该能很快捡起来。用实验室经费买的书也有好多没看，毕业之前我一定看完！\n代码质量方面应该是有所提升，毕竟被某个老哥狠狠喷了我的代码，这下的确是能做到代码要表达意图，而不是表达过程。\n每次看着网上和身边大佬们都这么强，还比我更专注更聪明更努力，偶尔掏出来的文章或作品都让人叹为观止，时常会觉得这辈子都难以超越，难免会自惭形秽。 这想法常常给我带来莫名的恐惧与痛苦，却又难以摆脱，更矛盾的是这些交织的感受又驱动着我不断挣扎向前。 与他人比较是错误的，但无奈我的确是被这种很罪恶的东西驱动，好在我不会通过与他人比较来获取幸福感，也算是小小慰藉。 我想还是尽可能在欲望和恐惧之间找到平衡，或许救赎之道就在其中，剩下的就交给命运吧！\n健康 不知道是笔试憋尿还是喝水喝少了，今年检查发现右肾长了颗结石。 虽然按医生的说法是比较小不用担心，但右腹平时还是会有疼痛感，于是去医院做了个无痛胃肠镜检查，好在没啥问题，应该还是肾结石的缘故，希望后面多喝水能把这玩意冲出来。 中间还和医生聊天，让他上药的时候告诉我一声，我来报数，看看凭借顽强的毅力能顶多久，但很快就彻底失去意识了，醒来之后还是医生告诉我数了十六下😭。\n秋招掉了不少头发，发际线发生了肉眼可见地后退，斥巨资尝试了一把米诺地尔，结果还是收效甚微，只好让大脑停摆一个月，总算止住了脱发的迹象。 现在看来，秃顶多半是避无可避了，但还是能拖延一下🤡。\n身体还是很重要的，今年由于某些原因没有坚持健身，后续还是要恢复一下的。\n未来 把欠下的课程补一补，至少下次遇到类似的问题的时候不再无从下手 继续健身，少去医院，还能长长肌肉，的确不错 想爬爬山，去西藏、新疆、日本旅游 profile一下自己的时间开销 学好英语，最好能和人无障碍沟通 后记 一只站在树上的鸟，从不会害怕树枝断裂，它相信的不是树枝，而是它自己的翅膀。\n回过头看，今年最重要的主线任务算是不那么完美地完成了，支线上也是完成了几个毕业条件，想想还是做了点事情。 其实大部分时间都过得相当零碎，很难说有什么积累和成长，平时都浮躁得静不下心，担忧着何去何从，还是得多想多做，尽可能冲淡这份感受。\n曾经对offer心心念念，真拿到后也没有太大变化，倒是多了一丝安全感，不用担心毕业即失业了。 这一年来在很多事情上都顶住了压力，不再随波逐流，慢慢构建起了自己的内核和做事的方法，对于生活也多了一份掌控感，开始逐渐期待未来的生活。\n世界在不断变化，没有什么是一成不变的，更没有什么事情做了之后能一辈子高枕无忧。所以今年的主题大概是拥抱变化，积极寻求改变，偶尔停下来思考，然后慢慢向前。\nBye ","date":"2024-12-10T15:29:29+08:00","permalink":"https://o-a-p.github.io/post/year/2024/","section":"post","tags":null,"title":"2024 拥抱变化"},{"categories":["C++"],"contents":"1. 前言 在C中调用一个函数，要么直接用函数名，要么用函数指针，但函数指针玩一些骚操作的时候灵活性有限。而function和bind作为C++11的两个模板类，能够封装类似函数指针的可调用对象，提供一致的调用接口，比原生的函数指针要更加灵活，也减少了许多心智负担。 👉 可调用对象 可调用对象：\n普通函数 类成员函数 类静态函数 仿函数/函数对象 lambda bind创建对象 这里分类并不十分精准，只是个人经验，更标准的分法是五种：\n函数 函数指针 lambda bind创建的对象 仿函数 两个模板类都在头文件\u0026lt;functional\u0026gt;中被定义。\n2. 使用 2.1 普通函数 以add和sub两个函数为例：\n1int add(int x, int y) { 2 return x + y; 3} 4 5int sub(int x, int y) { 6 return x - y; 7} 8 9function\u0026lt;int(int, int)\u0026gt; func = add; 10cout \u0026lt;\u0026lt; func(1, 2) \u0026lt;\u0026lt; endl; // 3 11 12func = sub; 13cout \u0026lt;\u0026lt; func(1, 2) \u0026lt;\u0026lt; endl; // -1 function模板在传入函数类型后就可以直接引用不同的函数，只要函数类型相同即可。\n再比如回调函数：\n1int callback(function\u0026lt;int(int, int)\u0026gt; func, int x, int y) { 2 return func(x, y); 3} 4 5cout \u0026lt;\u0026lt; callback(add, 1, 2) \u0026lt;\u0026lt; endl; // 3 bind则是起到绑定参数的作用，function配合bind则可以完成延迟调用。首先，bind的基本使用如下：\n1void print(const string\u0026amp; s1, const string\u0026amp; s2) { 2 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; 3} 4 5string s1{\u0026#34;hello\u0026#34;}, s2{\u0026#34;world\u0026#34;}; 6 7function\u0026lt;void()\u0026gt; f1 = bind(print, s1, s2); 8f1(); // hello world 这里很有意思，bind把print的参数绑定了，所以function对象的模板参数是void()，而非print的函数类型。bind还可以只绑定部分参数：\n1string s3{\u0026#34;hi\u0026#34;}; 2 3function\u0026lt;void(const string\u0026amp;)\u0026gt; f2 = bind(print, placeholders::_1, s2); 4f2(s3); // hi world placeholders::_1则是一个占位符，表示该参数在调用时被决定。 这里也可以看出来，bind返回的可调用对象的确“改变了函数的参数列表”，也比较符合bind的字面意思：绑定参数到可调用对象上。\n2.2 类成员函数 类成员函数则是需要一个实例对象才能调用（想想this），因此在使用bind包装时，要传入实例对象作为第一个参数。\n1class foo { 2public: 3 int add(int x, int y) { 4 return x + y; 5 } 6 static int sub(int x, int y) { 7 return x - y; 8 } 9}; 10 11foo foo1; 12auto f3 = bind(\u0026amp;foo::add, foo1, 10, 20); 13cout \u0026lt;\u0026lt; f3() \u0026lt;\u0026lt; endl; // 30 第一个参数仍然是函数地址，但不同的是多一个取地址符号，类成员函数通过\u0026amp;来标明这是一个成员函数，第二个参数则是实例对象。 foo1如果要以引用的方式传递的时候，或者说要更改foo1内部数据的时候，要以引用(std::ref)的方式传递。\n2.3 类静态函数 static函数属于类，所以无需对象也可调用，因此不用添加\u0026amp;。\n1auto f4 = bind(foo::sub, 10, 20); 2cout \u0026lt;\u0026lt; f4() \u0026lt;\u0026lt; endl; // -10 bind对于预先绑定的参数是pass-by-value的，要传递引用则需要使用std::ref或者std::cref，前者是传引用，后者是传const引用。\n1void add1(int \u0026amp;a) { 2 ++a; 3} 4 5int a = 1; 6auto f5 = bind(add1, a); 7f5(); 8cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1 9 10auto f6 = bind(add1, ref(a)); 11f6(); 12cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2 用std::ref则是传递引用，std::ref返回一个包装好的引用对象reference_wrapper，能够转换成被引用值的引用类型（内部本质就是传地址的）\nlambda和仿函数也是同理，无非是仿函数需要一个实例对象，此处不再赘述。\n1// lambda 2function\u0026lt;bool(const int\u0026amp;)\u0026gt; f1 = [](const int\u0026amp;a) { return a; }; 3// 仿函数，这里的foo()是创建临时对象，而非调用函数 4function\u0026lt;bool(const int\u0026amp;)\u0026gt; f2 = foo(); 2.4 访问类的成员 例子来自cpp reference，感觉很奇怪：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;functional\u0026gt; 3 4class Foo { 5public: 6 int num_; 7 8 Foo(int num) : num_(num) {} // 构造函数初始化 num_ 9}; 10 11int main() { 12 Foo foo(10); 13 14 // 创建一个 std::function 对象 f_num，它可以接受 Foo 类型的引用并返回 int 类型的值 15 std::function\u0026lt;int(const Foo\u0026amp;)\u0026gt; f_num = \u0026amp;Foo::num_; 16 17 // 通过传入 foo 对象的引用，使用 f_num 来获取 foo 对象的 num_ 成员变量的值 18 std::cout \u0026lt;\u0026lt; \u0026#34;num_: \u0026#34; \u0026lt;\u0026lt; f_num(foo) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // num_: 10 19 20 return 0; 21} 没想到居然还能访问数据成员，倒是一种用法。\n3. 参考 https://www.bilibili.com/video/BV1bm41197XV/?spm_id_from=333.788\u0026amp;vd_source=71ee144274d993f1c946fc98badf272d https://www.cnblogs.com/Philip-Tell-Truth/p/5814213.html https://en.cppreference.com/w/cpp/utility/functional/function ","date":"2024-10-21T14:55:00+08:00","permalink":"https://o-a-p.github.io/post/cpp/function-bind/","section":"post","tags":null,"title":"C++: functional"},{"categories":["Interview"],"contents":" 2024-09-13 update\n已经收到意向了，没想到结果却是好的，此事也算了结。\n前前后后花了约莫一个月，夜夜辗转反侧，此中滋味实在是不足为外人道也。\nTimeline：\n08/16 一面 08/20 二面 08/26 三面 09/04 hr面 09/13 意向 好像呼应了早先文末的一句“塞翁失马焉知非福”，实习面试的失败却意外促成了秋招面试的成功，也算某种意义上的“世事难料”。\n细碎念头很多，但今天却实在不想动笔，想太多倒也无用，未来怎么样就交给未来吧🙂。\n记录沉痛的失败\n1. Failure 1 今年4月找实习的时候被XX捞了，好不容易整到了二面，刁难人的智力题也回答来了，但倒在了手撕上：\n0-1背包问题 腐烂的橘子 大数乘法 二叉树的右视图 其实在这个时间点已经把hot100刷完了，还另外多刷了七八十道，想着手撕怎么也得优势在我，万万没想到tmd刷错了题单🤡。\n我刷的是所有题目中的题单LeetCode 热题 HOT 100，实际上hot100指的是LeetCode 热题 100，但这里的2. 4.两道手撕都只在后者里才有。\n到这里已经暴露了两个问题：\n和一起找实习的人交流过少，连leetcode刷错了都不知道 反应能力太差，二叉树的右视图不过是层序遍历取每一层的最后一个，当时太紧张没反应过来 但事后还没有仔细反省，整天乐乐呵呵的，于是就导致了第二次惨剧。\n2. Failure 2 就在昨天，已经干到XX三面了，细细想来已经是第8次面XX了，没想到又倒在了手撕上：\n相邻数字合并打印 快排递归改迭代 序列化和反序列化N叉树 大数乘法 前面两道磕磕绊绊倒是做出来了，第三道实在是不会（结束一查leetcode会员题，草），重点又是这该死的大数乘法。\n人不能在一个地方跌倒两次，自在上一次失败后，我把大数乘法的解法狠狠刻在大脑，没想到这次正好被我碰上了，于是十分钟不到就自信地撕出来了，但面试官一句不能用vector又将我打入深渊\u0026hellip;\u0026hellip;\n大数乘法在leetcode里是叫43. 字符串相乘，题解中官方解法如下：\n1class Solution { 2public: 3 string multiply(string num1, string num2) { 4 if (num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) { 5 return \u0026#34;0\u0026#34;; 6 } 7 int m = num1.size(), n = num2.size(); 8 auto ansArr = vector\u0026lt;int\u0026gt;(m + n); 9 for (int i = m - 1; i \u0026gt;= 0; i--) { 10 int x = num1.at(i) - \u0026#39;0\u0026#39;; 11 for (int j = n - 1; j \u0026gt;= 0; j--) { 12 int y = num2.at(j) - \u0026#39;0\u0026#39;; 13 ansArr[i + j + 1] += x * y; 14 } 15 } 16 for (int i = m + n - 1; i \u0026gt; 0; i--) { 17 ansArr[i - 1] += ansArr[i] / 10; 18 ansArr[i] %= 10; 19 } 20 int index = ansArr[0] == 0 ? 1 : 0; 21 string ans; 22 while (index \u0026lt; m + n) { 23 ans.push_back(ansArr[index]); 24 index++; 25 } 26 for (auto \u0026amp;c: ans) { 27 c += \u0026#39;0\u0026#39;; 28 } 29 return ans; 30 } 31}; 思路非常清晰：\n从低位到高位依次相乘，将结果存在每一位应该在的位置，这里有个推论：第i位和第j位的乘积是在第i+j+1位 这里由于是用vector来存，不用在乘法过程中考虑进位，后面专门有个for循环来处理进位 删除前导0，并收集结果 如此清晰易懂很难让人不学习，但忽略了使用string也可以达到相同的效果：\n1class Solution { 2public: 3 string multiply(string num1, string num2) { 4 if(num1 == \u0026#34;0\u0026#34; || num2 == \u0026#34;0\u0026#34;) { 5 return \u0026#34;0\u0026#34;; 6 } 7 8 int m = num1.size(); 9 int n = num2.size(); 10 11 string res(m + n, \u0026#39;0\u0026#39;); 12 13 for (int i = m - 1; i \u0026gt;= 0; --i) { 14 int n1 = num1[i] - \u0026#39;0\u0026#39;; 15 for (int j = n - 1; j \u0026gt;= 0; --j) { 16 int n2 = num2[j] - \u0026#39;0\u0026#39;; 17 int n3 = res[i + j + 1] - \u0026#39;0\u0026#39; + n1 * n2; 18 res[i + j + 1] = n3 % 10 + \u0026#39;0\u0026#39;; 19 res[i + j] += n3 / 10; 20 } 21 } 22 23 for (int i = 0; i \u0026lt; m + n; ++i) { 24 if (res[i] != \u0026#39;0\u0026#39;) return res.substr(i); 25 } 26 return \u0026#34;0\u0026#34;; 27 } 28}; 这里思路大体相同，这里唯一要注意的是一个char类型本质上也是存的整数，所以可以处理超过10的进位，而不是只能存字符0-9，但直到yp提醒我才发觉这一点，谢谢你yp。\n我太蠢了，以前当助教总因为别人不懂怎么把数字和字符相互转换扣别人的分，直到今天我才发现真正应该被扣分的人是我啊🤡。\n出来混，迟早要还，这下不但面试G了，还得泡池子被人按住当分母了😭，草！\n3. 啊！失败 不过塞翁失马焉知非福？\n突然跳出思维的陷阱让人在苦苦秋招的同时恍惚间有了一些实感 偶尔停下来思考也许能省去很多未来的烦恼 失败倒是让人放平心态，面对现实，不再逃避，毕竟哪有事事如意 说来说去好像都是一些细碎的念头，一边写一边遗憾地自娱自乐，不过好在如今都落在文字上也算进步，希望偶尔再看能提醒自己不再踩坑，继续前进。\n人总是要长大。已经发生的事，已经没了的人，总是回头看也没用，只能把现在的事情做得漂亮点。\n最后，谢谢你看到这里🙂，共勉！\nend ","date":"2024-08-27T21:24:59+08:00","permalink":"https://o-a-p.github.io/post/failure/two-failed-interviews/","section":"post","tags":null,"title":"记两次失败的面试"},{"categories":["Travel"],"contents":"上次来南昌还是22年毕业后当舔狗来了一回，去了滕王阁和南昌之星，跟朋友分享我的舔狗故事后，旅行地点就被巧合地定在了南昌。\n于是上个周末，恰好几个小伙伴都有空，忙里偷闲趁着周末速通了下南昌。左右闲来无事，记录下旅行流水账。\n1. Day1 周五晚上在酒店集合，我们几个到的比较晚的去搓了顿烧烤，店名没啥新意：熊氏烧烤，但不愧是上过人生一串的店，五花肉和小猪肉的味道不错，其他串一般。\n上次来比较痛苦，印象不深，这次仔细观察了下，南昌站这边比较旧，都是老城区，武汉待久了，对比下来，感觉南昌比武汉小得多，却也刚好合适，半个多小时基本能东西横跨南昌，打车便宜😁。\n2. Day2 原计划是去大觉山漂流，但没买到团购票，加上只有一个周末，不想把太多时间浪费在路上，便只好退而求其次，去了梅岭漂流。由于前一天很晚才到南昌，第二天9点才起床，去王府井商场买了防晒用品便坐车出发去了梅岭。\n这里应配图一张，但当时对着朋友激情献唱《泪桥》，忘拍了，不妨用伍佰老师的歌来替代。\n老实说，作为人生中第一次漂流，梅岭虽然不太刺激，但倒也恰到好处，遗憾的是五个人只能坐两艘漂流船，没有一艘玩来得尽兴。另外，玩漂流还是得准备个质量好的水枪，不要在漂流点买，不然玩一会就坏了，后半程只能挨打。🤬🤬🤬\n漂流完可以坐大巴回去拿寄存的东西和洗澡，不过当时倒霉洗的是冷水，还没带干衣服，只好回酒店换衣服。\n晚上大家齐聚不知名小店吃饭，不过太辣，味道也一般，第一次知道冰棍能tnnd镇辣。\n3. Day3 中午在食在鲜南昌吃的，极其一般般，早知道去堂瓦里了，虽然回忆不太美好，但味道一绝。\n可惜的是晚上就得赶回去了，也没有去太远的地方玩，打卡了八一广场和江西省美术馆，顶着烈日拍了很多打卡照片，不过我最爱的还是这张。\n美术馆有些克苏鲁展品难以评价，可能这就是艺术吧。\n不理解，尊重，祝福。\n4. 啊！人生 匆忙来回，难得一聚，朋友们的生活都陆续稳定，只剩自己没有定论，仍然充满未知。挣扎求索，苦中作乐，只希望这匆忙不会是未来生活的一角。\n最后用一句很有启发意义的话来结尾罢！\nend ","date":"2024-08-06T21:42:01+08:00","permalink":"https://o-a-p.github.io/post/travel/nanchang/","section":"post","tags":null,"title":"再会南昌"},{"categories":["x86-asm","CSAPP"],"contents":" 题意很简单，题目给出一个二进制可执行文件，要求通过反汇编等一系列破解六个密码。 密码都被封装到phase_1~phase_6六个函数中，如果输入错误则会引爆。\n前置准备：先用如下指令把汇编输出到文件里，用vscode看看\nobjdump -d bomb \u0026gt; bomb.asm\n然后记住六个参数是：\nrdi rsi rdx rcx r8 r9，第七个参数就是通过栈来传递，返回参数在rax中\n1. phase_1 首先还是得看看汇编，其汇编如下：\n10000000000400ee0 \u0026lt;phase_1\u0026gt;: 2 400ee0: 48 83 ec 08 sub $0x8,%rsp 3 400ee4: be 00 24 40 00 mov $0x402400,%esi 4 400ee9: e8 4a 04 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; 5 400eee: 85 c0 test %eax,%eax 6 400ef0: 74 05 je 400ef7 \u0026lt;phase_1+0x17\u0026gt; 7 400ef2: e8 43 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 8 400ef7: 48 83 c4 08 add $0x8,%rsp 9 400efb: c3 retq 几乎是明牌了，第二行为函数开辟栈空间，mov指令把地址0x402400放到寄存器esi中，随后调用strings_not_equal这个函数（第一个第二个传入参数会被分别放到rdi和rsi两个寄存器中），由于知道x86把返回值放到rax寄存器中，后面会有一个判断结果的流程，再往后就是引爆炸弹了。 根据流程分析代码应该如下：\n1void phase_1(char* input) { 2 char* a = \u0026#34;123123123\u0026#34;; // 这里只是代指，并非真正密码 3 if(strings_not_equal(a, input)) { 4 explode_bomb(); 5 } 6} 所以思路很明显了，直接gdb ./bomb，查看一下0x402400处内存就OK，具体如下：\n1(gdb) x/s 0x402400 20x402400: \u0026#34;Border relations with Canada have never been better.\u0026#34; 这里x/s表示按字符串查看指定位置内存（妈的之前不知道还一个个查表，真蠢） 最后在运行bomb输入密码即可，不带引号\n2. phase_2 这里直接给出注释：\n10000000000400efc \u0026lt;phase_2\u0026gt;: 2 400efc: 55 push %rbp # 压栈两个要用到的寄存器 3 400efd: 53 push %rbx 4 400efe: 48 83 ec 28 sub $0x28,%rsp # 为函数开辟空间 5 400f02: 48 89 e6 mov %rsp,%rsi # 把栈指针用作函数参数 6 400f05: e8 52 05 00 00 callq 40145c \u0026lt;read_six_numbers\u0026gt;# 字面意义上从input中读取6个数字，可以想象数字被读取之后一定是存在栈上的（考虑到局部变量通过栈传递，以及上面一行把rsp传入该函数） 7 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) # 比较rsp寄存器所指的数据与1大小，那么此时rsp所指的位置必然存在六个数字，这里将第一个数字和1比较。 8 400f0e: 74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; # 如果相等就跳转到30位置上 9 400f10: e8 25 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 否则就引爆 10 400f15: eb 19 jmp 400f30 \u0026lt;phase_2+0x34\u0026gt; # 引爆后再跳到30位置上 11 400f17: 8b 43 fc mov -0x4(%rbx),%eax # 将地址rbx-4内存处数据移动到eax，如果是第一次到此处，那此时eax中就是第一个数字，也就是1 12 400f1a: 01 c0 add %eax,%eax # 将eax乘以2 13 400f1c: 39 03 cmp %eax,(%rbx) # 将eax数据与rbx指向数据比较，如果是第一次到此处，那这行的意思就是把第一个数字的二倍和第二个数字比较 14 400f1e: 74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; # 相等跳到25位置，此时可以确认，要求是让第一个数字的两倍和第二个数字相等，依次递增 15 400f20: e8 15 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 否则引爆 16 400f25: 48 83 c3 04 add $0x4,%rbx # 将rbx中数据加4，若第一次到此处，那此时指向第三个数字 17 400f29: 48 39 eb cmp %rbp,%rbx # 比较rbx和rbp中的地址数据，控制循环次数 18 400f2c: 75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; # 如果不相等就跳转到17位置，继续循环 19 400f2e: eb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; # 相等就跳转到3c位置，停止循环 20 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx # 将0x4和rsp加起来将其中地址赋值给rbx，如果是第一次到此处，那么rbx保存的就是第二个数字的地址 21 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp # 将0x18和rsp加起来将其中地址赋值给rbp，0x18=4*6=24，因此指向最后一个元素的末尾！ 22 400f3a: eb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; # 跳转到17位置 23 400f3c: 48 83 c4 28 add $0x28,%rsp # 恢复栈 24 400f40: 5b pop %rbx # 恢复寄存器 25 400f41: 5d pop %rbp 26 400f42: c3 retq 刚开始压栈和开辟空间没什么好说的，但需要注意这里开辟了0x28大小的空间，这相当的大，下一步把rsp传给了rsi，也就是第二个参数寄存器，从C代码中可以看到phase都只有一个参数，因此rsi没用上。\n但后续调用read_six_numbers显然是用上了这个rsi，从字面意思来看，要从input读取六个数字，那返回值要放在哪里呢？显然没有放在堆上，而是通过第二参数放在了其指向的地址上，也就是栈上！\n下一步是将rsp所指的数据和1比较，显然rsp指向六个中的第一个，那第一个数字必然是1。后面跳转到指定位置上，具体的步骤是将rbx指向了下一个数字，将rbp指向了最后一个数字的末尾！随后继续跳转。\n后面跳转到的是获取上一个数字并将其乘以2与自己比较，那很明显就是当前数字必须是前一个数字的两倍，随后跳转到循环的判断语句上，判断是否到达了循环次数！\n由此可见类似的C代码应该是：\n1void phase_2(char *input) { 2 int a[6]; 3 read_six_numbers(input, a); 4 if (a[0] != 1) explode_bomb(); 5 for (int i = 1; i \u0026lt; 6; i++) { 6 if(a[i] != 2 * a[i - 1]) { 7 explode_bomb(); 8 } 9 } 10} 所以显而易见，要输入的密码应该是1 2 4 8 16 32 64\n3. phase_3 同样给出注释\n10000000000400f43 \u0026lt;phase_3\u0026gt;: 2 400f43: 48 83 ec 18 sub $0x18,%rsp # 预留空间 3 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx # 第四参数寄存器的值是rsp+12 4 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx # 第三参数寄存器的值是rsp+8，猜想可能是获取数据 5 400f51: be cf 25 40 00 mov $0x4025cf,%esi # 把某个地址的数据放到esi中了，而esi是第二个参数寄存器，32位，第一个参数寄存器已经放了input，从后面可知这里应该是format字符串 6 400f56: b8 00 00 00 00 mov $0x0,%eax # 把0放到eax中，rax是返回值寄存器 7 400f5b: e8 90 fc ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; # 调用sscanf函数，int sscanf(const char *str, const char *format, ...); 8 # 猜想是sscanf(input, esi指向的字符串, 返回参数)，得gdb看一下format 9 400f60: 83 f8 01 cmp $0x1,%eax # 此时eax返回值是解析成功了几个，从gdb中可以看出是两个整形参数 10 400f63: 7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; # 如果是eax\u0026gt;1就跳转6a，否则爆炸 11 400f65: e8 d0 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 12 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) # 比较四个字节，比较rsp+8位置的数据，也就是第三个参数和0x7的关系 13 400f6f: 77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; # 如果是大于就跳转ad位置，ad位置是爆炸，也就是说第三个参数不能大于7 14 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax # 把第三参数放到eax中，假设第三参数是0，那就是跳转到0x402470处 15 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) # 间接跳转0x402470内存处的地址，gdb看了，输入两个参数且第一个参数为0时是0x400f7c 16 400f7c: b8 cf 00 00 00 mov $0xcf,%eax # 覆盖eax为0xcf 17 400f81: eb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; # 跳转到be位置 18 400f83: b8 c3 02 00 00 mov $0x2c3,%eax 19 400f88: eb 34 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 20 400f8a: b8 00 01 00 00 mov $0x100,%eax 21 400f8f: eb 2d jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 22 400f91: b8 85 01 00 00 mov $0x185,%eax 23 400f96: eb 26 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 24 400f98: b8 ce 00 00 00 mov $0xce,%eax 25 400f9d: eb 1f jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 26 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax 27 400fa4: eb 18 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 28 400fa6: b8 47 01 00 00 mov $0x147,%eax 29 400fab: eb 11 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 30 400fad: e8 88 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 31 400fb2: b8 00 00 00 00 mov $0x0,%eax 32 400fb7: eb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 33 400fb9: b8 37 01 00 00 mov $0x137,%eax 34 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax # 比较第四参数和0xcf 35 400fc2: 74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; # 如果相等就跳转到c9位置结束 36 400fc4: e8 71 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 37 400fc9: 48 83 c4 18 add $0x18,%rsp 38 400fcd: c3 retq 首先就搞了两个变量，显然是为了存返回数据，后续又马上调用了sscanf，查一下sscanf的函数说明：\n1int sscanf(const char *str, const char *format, ...); // int为成功获取参数个数 rsi是第二参数，可以看到第五行给了一个地址过去，用gdb查看一下发现是%d %d，由此不难推断出要按俩参数。\n而前面搞的俩栈上变量显然是用来存储读取到的数据\neax获取解析了几个，后面如果eax\u0026gt;1则继续执行，侧面验证了要按俩参数\n后续又比较第一个参数和7，大于7就会爆炸，因此第一个参数不能大于7，后续往下，根据第一个参数是什么来实行间接跳转，这里我随便写个0，转到gdb看一下跳转地址，应该是一个类似switch的东西，随后直接算出来第二个参数是0xcf即207\n可以猜测一下C代码结构：\n1void phase_3(char* input){ 2 int a, b; 3 int res = sscanf(input, \u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); 4 if (res \u0026lt;= 1) { 5 explode_bomb(); 6 } 7 if (a \u0026gt; 7) { 8 explode_bomb(); 9 } 10 switch(a) { 11 case 0: 12 if (b != 207) { 13 explode_bomb(); 14 } 15 break; 16 case 1: 17 ... 18 } 19} 所以正确答案是0 207\n4. phase_4 首先还是先看汇编：\n1000000000040100c \u0026lt;phase_4\u0026gt;: 2 40100c: 48 83 ec 18 sub $0x18,%rsp # 预留空间 3 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx # 准备第四参数 4 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx # 准备第三参数 5 40101a: be cf 25 40 00 mov $0x4025cf,%esi # 第二参数，具体存的东西在0x4025cf处，和phase_3一样%d %d 6 40101f: b8 00 00 00 00 mov $0x0,%eax # 清理eax 7 401024: e8 c7 fb ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; # 调用sscanf 8 401029: 83 f8 02 cmp $0x2,%eax # 将成功获取参数个数与2比较 9 40102c: 75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; # 如果不等于就跳转35处爆炸 10 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) # 此时是等于2的，将获取到的第三参数与0xe比较，即第一个数字 11 401033: 76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; # 如果第三参数\u0026lt;=0xe就跳转3a处，否则就爆炸，所以第一个数字一定要小于等于0xe=14 12 401035: e8 00 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 13 40103a: ba 0e 00 00 00 mov $0xe,%edx # 将0xe放入edx中，用作func4的第三参数 14 40103f: be 00 00 00 00 mov $0x0,%esi # 将0放入esi中，用作func4的第二参数 15 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi # 获取第一个数字将其放入edi中，用作func4的第一参数 16 401048: e8 81 ff ff ff callq 400fce \u0026lt;func4\u0026gt; # 调用func4，这里不确定func4有几个参数，但在这个函数里面至少有三个，也有可能有四个 17 40104d: 85 c0 test %eax,%eax # 测试返回值是否为0 18 40104f: 75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt; # 如果非0就跳转爆炸 19 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) # 是0就把第二个数字与0比较 20 401056: 74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt; # 如果相等就结束，所以第二个数字必然为0 21 401058: e8 dd 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 22 40105d: 48 83 c4 18 add $0x18,%rsp 23 401061: c3 retq 可以看到，首先是准备参数，随后和phase3中一样从input中提取数字，gdb看一下也是%d %d，并且将获取成功的参数与2相比是否正确，随后检查第一个数字是否是小于14，如果是就调用func4，不是就爆炸，获取func4返回值看是否为0，是的话就比较第二个数字是否为0，是0就成功\n所以显然第一个数字小于等于14，第二个数字为0\n这里可以尝试一手0 0，再进func4分析，func4汇编如下：\n10000000000400fce \u0026lt;func4\u0026gt;: # rdi rsi rdx，第一次调用分别为: 第一个数字，0，0xe=14 2 400fce: 48 83 ec 08 sub $0x8,%rsp # 预留空间 3 400fd2: 89 d0 mov %edx,%eax # 把第三参数存到eax中 eax = edx = 14 4 400fd4: 29 f0 sub %esi,%eax # 把eax中的第三参数减去第二参数 eax = eax - esi = 14 5 400fd6: 89 c1 mov %eax,%ecx # 把eax中减去第二参数的第三参数放到ecx寄存器里，从此处基本确定这个函数有三个参数 ecx = eax = 14 6 400fd8: c1 e9 1f shr $0x1f,%ecx # 逻辑右移0x1f个位置存到ecx中 ecx\u0026gt;\u0026gt;0x1f（相当于取最高位的0或者1） ecx = 0 7 400fdb: 01 c8 add %ecx,%eax # 把ecx和eax相加存到eax中 eax = ecx + eax eax = 14 8 400fdd: d1 f8 sar %eax # 算术右移但没写移几位，这里debug了一下发现是除以2，所以应该是取默认值为1，即右移一位 9 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx # 把rax+rsi赋值给ecx 10 400fe2: 39 f9 cmp %edi,%ecx # 比较edi和ecx 11 400fe4: 7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; # 如果ecx \u0026lt;= edi就跳转f2位置 12 400fe6: 8d 51 ff lea -0x1(%rcx),%edx # 否则就将rcx-1赋值给edx 13 400fe9: e8 e0 ff ff ff callq 400fce \u0026lt;func4\u0026gt; # 递归调用 14 400fee: 01 c0 add %eax,%eax # 把返回值eax * 2 相当于return 2 * func4() 15 400ff0: eb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; # 结束 16 400ff2: b8 00 00 00 00 mov $0x0,%eax # 把0赋值给eax 17 400ff7: 39 f9 cmp %edi,%ecx # 比较ecx和edi 18 400ff9: 7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; # 若 ecx\u0026gt;=edi，就跳转07位置 19 400ffb: 8d 71 01 lea 0x1(%rcx),%esi # 否则把rcx+1赋值给esi 20 400ffe: e8 cb ff ff ff callq 400fce \u0026lt;func4\u0026gt; # 递归调用 21 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax # 相当于返回 2 * eax + 1 相当于return 2 * func4() + 1 22 401007: 48 83 c4 08 add $0x8,%rsp 23 40100b: c3 retq 显然是个很坑的递归，可以一行行将其换成C如下，注意gdb里尝试的sar %eax不带移动位数就默认是移动1位，最终可以知道递归代码如下。一通分析发现第一个数字是0。\n1// 第一次进入分别为：第一个数字，0，14 2int func4(int a, int b, int c) { 3 int tmp1 = c - b; 4 int tmp2 = tmp1 \u0026gt;\u0026gt; 31; 5 tmp1 = tmp2 + tmp1; 6 tmp1 = tmp1 / 2; 7 tmp2 = tmp1 + b; 8 if (tmp2 \u0026lt;= a) { 9 tmp1 = 0; 10 if (tmp2 \u0026gt;= a) { 11 return 0; 12 } else { 13 b = tmp2 + 1; 14 return 2 * func4(a, b, c) + 1; 15 } 16 } else { 17 c = tmp2 - 1; 18 return 2 * func4(a, b, c); 19 } 20} 因此第一个密码是0，第二个密码也是0。\n5. phase_5 老规矩查看汇编：\n10000000000401062 \u0026lt;phase_5\u0026gt;: 2 401062: 53 push %rbx # 后面要用到rbx，压栈 3 401063: 48 83 ec 20 sub $0x20,%rsp # 开辟空间 4 401067: 48 89 fb mov %rdi,%rbx # 把input放到rbx中。rbx和rdi都指向input 5 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax # ？似乎是把什么玩意放到rax中 6 401071: 00 00 7 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) # 把rax寄存器的数据放到栈中，也就是金丝雀值 8 401078: 31 c0 xor %eax,%eax # 将eax清零 9 40107a: e8 9c 02 00 00 callq 40131b \u0026lt;string_length\u0026gt; # 显然是获取字符串长度，将结果返回到eax中 10 40107f: 83 f8 06 cmp $0x6,%eax # 比较字符串长度和6 11 401082: 74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; # 如果相等就跳转d2位置，也就是说字符串长度得是6 12 13 401084: e8 b1 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 否则爆炸 14 401089: eb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 15 16 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx # 将rbx+rax所指向的数据放到ecx中，rbx指向input，rax从0到5，也就是第一个字符 17 40108f: 88 0c 24 mov %cl,(%rsp) # 将该字符压入栈上 18 401092: 48 8b 14 24 mov (%rsp),%rdx # 把该字符放入rdx中 19 401096: 83 e2 0f and $0xf,%edx # 0xf与第一个字符做与操作，再把结果存到edx中，相当于只保留低4位 20 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx # 再把保留低4位的值 + 0x4024b0所指向的数据放回edx中，gdb查看一手 21 # 查看结果如下：maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you? 22 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) # 把获取到的字符放到，0x10+rsp+rax所指向的地址，而rax从0到5，因此放入的位置是rsp+0x10到rsp+0x15 23 4010a4: 48 83 c0 01 add $0x1,%rax # 把rax+1 24 4010a8: 48 83 f8 06 cmp $0x6,%rax # 比较rax和6的大小 25 4010ac: 75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; # 如果不相等就回退到8b位置，所以这是个循环 26 27 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) # 相等就把栈上0x16位置赋值为0，相当于结束符 28 4010b3: be 5e 24 40 00 mov $0x40245e,%esi # 把0x40245e赋值给%esi，gdb查看了一下发现是：flyers 29 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi # 把rsp + 0x10赋值给rdi 30 4010bd: e8 76 02 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; # 调用函数，显然有俩参数 31 4010c2: 85 c0 test %eax,%eax # 比较返回值是否相等 32 4010c4: 74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; # 如果相等就跳转到d9位置结束 33 4010c6: e8 6f 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 34 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) # 无用 35 4010d0: eb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 36 37 4010d2: b8 00 00 00 00 mov $0x0,%eax # 将eax置零 38 4010d7: eb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; # 跳转到8b位置 39 40 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax # 把rax寄存器的数据恢复 41 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax # 比较金丝雀值 42 4010e5: 00 00 43 4010e7: 74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; # 如果相等就跳出，否则就继续 44 4010e9: e8 42 fa ff ff callq 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 45 4010ee: 48 83 c4 20 add $0x20,%rsp 46 4010f2: 5b pop %rbx 47 4010f3: c3 retq 这题倒也简单，一看就知道是个循环，主要代码分为三部分：\n判断输入字符串的长度，从上面可以看出，如果不是6个字符就会爆炸 循环六个字符的低四位，并以此为索引从内存中找到六个对应字符，也就是从那一大串中找，并把六个对应字符存到栈上 将栈上六个字符与另外六个字符（flyers）相比较，如果不同就爆炸！ 以第一个字符f为例，要找到这个字符，偏移量必须为9，大小写的I都可以做到，后续按照规律分别可以找到：IONEFG，大小写皆可，哪怕不是这些字符都OK，只要是ascii码低四位偏移量能够找到目标字符即可。 6. phase_6 这一关比较难，分段分析：\n100000000004010f4 \u0026lt;phase_6\u0026gt;: 2 4010f4: 41 56 push %r14 # 压栈一些寄存器 3 4010f6: 41 55 push %r13 4 4010f8: 41 54 push %r12 5 4010fa: 55 push %rbp 6 4010fb: 53 push %rbx 7 4010fc: 48 83 ec 50 sub $0x50,%rsp # 保留一段栈用于该函数 8 401100: 49 89 e5 mov %rsp,%r13 # 把rsp存到r13中，r13= rsp 9 401103: 48 89 e6 mov %rsp,%rsi # 再把rsp存到rsi中 10 401106: e8 51 03 00 00 callq 40145c \u0026lt;read_six_numbers\u0026gt; # rdi是input，rsi是rsp，所以是从input中读取六个数字到栈上 11 40110b: 49 89 e6 mov %rsp,%r14 # 把rsp存到r14中 r14 = rsp 12 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d # 将r12置零 r12 = 0 13 14 401114: 4c 89 ed mov %r13,%rbp # 将r13的数据置给rbp，也就是说使得rbp = rsp，rbp = rsp + 4（第二次） 15 401117: 41 8b 45 00 mov 0x0(%r13),%eax # 获取第一个数字，传给eax | 获取第二个数字 16 40111b: 83 e8 01 sub $0x1,%eax # 将第一个数字-1 | 第二个数字-1 17 40111e: 83 f8 05 cmp $0x5,%eax # 与5比较 18 401121: 76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt;# 如果 数字-1 \u0026lt;= 5，就跳转28处，这说明数字必须小于等于6 19 401123: e8 12 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 20 401128: 41 83 c4 01 add $0x1,%r12d # 给r12+1，此时r12 = 1 21 40112c: 41 83 fc 06 cmp $0x6,%r12d # 将r12与6比较 22 401130: 74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt;# 如果相等就跳转53 23 401132: 44 89 e3 mov %r12d,%ebx # 将r12的值放入ebx，ebx = 1 24 25 401135: 48 63 c3 movslq %ebx,%rax # 将ebx的值放入rax，rax = 1 26 401138: 8b 04 84 mov (%rsp,%rax,4),%eax # 将rsp+4*rax指向的数据放入eax，也就是第二个数据 27 40113b: 39 45 00 cmp %eax,0x0(%rbp) # 比较eax和第一个数字，比较第一二个数字 28 40113e: 75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt;# 如果不相等就跳转45处，也就是说让第1 2个数字不相等 29 401140: e8 f5 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 30 401145: 83 c3 01 add $0x1,%ebx # ebx = 2 31 401148: 83 fb 05 cmp $0x5,%ebx # 将ebx与5比较 32 40114b: 7e e8 jle 401135 33 \u0026lt;phase_6+0x41\u0026gt;# ebx \u0026lt;= 5就跳转35处，所以此处是个循环，循环比较其他数字和第一个数字，让所有数字都不与第一个数字相同 这一段的意思很简单，就是从input中读6个数字，将其与6比较，保证每个数字都小于等于6.\n同时后面有个双层循环，使得6个数字互不相等。所以按照推测后面的代码应该是决定这六个数字的顺序\n1 40114d: 49 83 c5 04 add $0x4,%r13 # r13等于rsp，相当于让r13指向第二个数字 2 401151: eb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt;# 这里也是循环，相当于让每个数字都相互比较，使之个个都不相等，且小于等于6 3 4 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi # 把rsp+18地址给rsi，也就是最后一个元素 5 401158: 4c 89 f0 mov %r14,%rax # 让rax = r14 = rsp 6 40115b: b9 07 00 00 00 mov $0x7,%ecx # 让ecx = 0x7 7 8 401160: 89 ca mov %ecx,%edx # 让edx = ecx = 0x7 9 401162: 2b 10 sub (%rax),%edx # 让0x7 - 第一个元素 10 401164: 89 10 mov %edx,(%rax) # 把结果再放到原位置 11 401166: 48 83 c0 04 add $0x4,%rax # 移动到下一个元素 12 40116a: 48 39 f0 cmp %rsi,%rax # 比较是否到达最后一个元素 13 40116d: 75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt;# 如果没到就跳转到60处，继续这个循环，相当于让每个数字=0x7-数字 14 15 40116f: be 00 00 00 00 mov $0x0,%esi # esi = 0 16 401174: eb 21 jmp 401197 \u0026lt;phase_6+0xa3\u0026gt;# 跳转到97处，此时上一个循环完毕开启下一个循环 让每个数字都等于7-数字，目前尚且不知道有啥用\n1 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx # rdx存储rdx+0x8处的数据，这里一直不明白，看了别人的解析才懂原来是链表操作 2 # 相当于把下一个节点的指针放到rdx里 3 40117a: 83 c0 01 add $0x1,%eax # 让eax++，eax随着循环内部循环增长，比较其与大于1的元素的关系 4 40117d: 39 c8 cmp %ecx,%eax # 比较ecx和eax，而ecx是大于1的元素 5 40117f: 75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt;# 如果不相等就跳转76，继续让rdx前进，同时让eax+1，也就是找到存放指定数据的节点 6 401181: eb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt;# 反之跳转88，也就是说找到和数字匹配的链表节点 7 8 401183: ba d0 32 60 00 mov $0x6032d0,%edx # 又让edx存了该地址，小于1的逻辑，gdb看了一下，这是链表head地址 9 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2)# 让rdx放到rsp + 0x20 + rsi * 2处。 10 # 说明栈中元素大小是8，也就是说栈上存的是指针，这里就是把每个节点的指针保存下来，保存到栈上 11 40118d: 48 83 c6 04 add $0x4,%rsi # 让rsi移动4 12 401191: 48 83 fe 18 cmp $0x18,%rsi # 比较rsi与0x18，24是终点，说明要移动6次到达终点 13 401195: 74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt;# 如果相等就跳转ab处，显然一开始不会相等，所以要循环 14 15 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx # 使得ecx的值为rsp + rsi指向处，猜测也是移动指针，此时ecx中保存第一个元素，第二次进来就是第二个数据 16 40119a: 83 f9 01 cmp $0x1,%ecx # 比较第一个元素与1 比较第二个数据 17 40119d: 7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt;# 如果ecx \u0026lt;= 0x1，就跳转83位置，也就是说该循环比较每个元素与1的大小，所以83处是\u0026lt;=1的处理逻辑 18 19 40119f: b8 01 00 00 00 mov $0x1,%eax # eax = 1，这是大于1的处理逻辑 20 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx # edx存的是0x6032d0这个地址 21 4011a9: eb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt;# 跳转76处 这里出现了一个地址0x6032d0，用gdb查看一下其内存数据，发现是链表，很显然可以看到低地址是数据，高地址是指针。这里要注意第一行的数据其实就是跑到移动到下一个节点。\n1(gdb) x/12xg 0x6032d0 20x6032d0 \u0026lt;node1\u0026gt;: 0x000000010000014c 0x00000000006032e0 30x6032e0 \u0026lt;node2\u0026gt;: 0x00000002000000a8 0x00000000006032f0 40x6032f0 \u0026lt;node3\u0026gt;: 0x000000030000039c 0x0000000000603300 50x603300 \u0026lt;node4\u0026gt;: 0x00000004000002b3 0x0000000000603310 60x603310 \u0026lt;node5\u0026gt;: 0x00000005000001dd 0x0000000000603320 70x603320 \u0026lt;node6\u0026gt;: 0x00000006000001bb 0x0000000000000000 此处逻辑就是把链表中每个节点的地址按照六个数字的顺序放入栈中\n1 # 代码到达此处之前已经完成了寻找操作，此时从rsp+0x20处开始都是指针数据，大小为8字节 2 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx # 把rsp+0x20处的数据放到rbx中 也就是说是第一个节点内的数据 3 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax # 让0x28+rsp放到rax处 循环开始位置 也就是说是第二个节点的地址 4 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi # 让0x50+rsp放到rsi处 循环结束位置 最后一个位置 5 4011ba: 48 89 d9 mov %rbx,%rcx # rcx = rsp + 0x20处的数据。 也就是第一个节点内的数据 6 7 4011bd: 48 8b 10 mov (%rax),%rdx # 取第二个节点数据，将其放到rdx中 8 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) # 其实就是把节点重新连接了起来，按照在栈中的顺序，得偏移8个字节才能找到指向下一个节点的指针 9 4011c4: 48 83 c0 08 add $0x8,%rax # 把rax数据+8 rax = 0x30 + rsp，移动循环变量 10 4011c8: 48 39 f0 cmp %rsi,%rax # 比较rsi和rax，看看是否到了结尾 11 4011cb: 74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt;# 如果相等就跳d2 12 4011cd: 48 89 d1 mov %rdx,%rcx 13 4011d0: eb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt;# 跳转到bd处 可以看到这里其实就是把栈中的链表节点按照栈中的顺序连接起来！\n1 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) # 给最后一个节点的指针域赋值为null 2 4011d9: 00 3 4011da: bd 05 00 00 00 mov $0x5,%ebp # 把0x5赋值为ebp 4 4011df: 48 8b 43 08 mov 0x8(%rbx),%rax # 将下一个节点的地址赋值给rax，因为在上一轮循环中rbx指向第一个链表元素 5 4011e3: 8b 00 mov (%rax),%eax # 访问节点的数据，并将数据复制给eax，注意这里只复制了低4个字节，从gdb中可以看到是有一串数字的 6 4011e5: 39 03 cmp %eax,(%rbx) # 比较eax和rbx，也就是说上一个节点和下一个节点比较 7 4011e7: 7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt;# 要让上一个节点的数据大于下一个节点的数据 8 4011e9: e8 4c 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt;# 否则就引爆 9 4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx # 移动链表 10 4011f2: 83 ed 01 sub $0x1,%ebp # 减去控制移动的东西，检查是否遍历完成 11 4011f5: 75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; 12 13 4011f7: 48 83 c4 50 add $0x50,%rsp # 恢复现场 14 4011fb: 5b pop %rbx 15 4011fc: 5d pop %rbp 16 4011fd: 41 5c pop %r12 17 4011ff: 41 5d pop %r13 18 401201: 41 5e pop %r14 19 401203: c3 retq 先把最后一个节点的指针赋值为null，并通过ebp控制循环次数，检验链表前一个节点数据必须大于后一个节点数据！ 所以根据gdb中的链表数据显示，在7减去数字之后的顺序应该是：3 4 5 6 1 2 也就是说初始数字应该是4 3 2 1 6 5\n小结 看起来好像还有个secret phase，不过到此汇编应该就结束了，追求的也是能看懂，目前看简单的汇编也是没有问题了，bomb实验真的不错！之后有空再推进吧。\n八股，爷来了！\n参考 老哥1 老哥2 老哥3 ","date":"2024-02-20T20:48:54+08:00","permalink":"https://o-a-p.github.io/post/csapp/bomb/","section":"post","tags":null,"title":"CSAPP：bomb lab"},{"categories":["OS","6.S081"],"contents":"xv6的进程切换是需要在内核中切换的，一个进程通过定时器中断陷入操作系统时，usertrap处理程序检测到是定时器中断，说明该进程需要让出CPU的使用权，此时需要经历以下过程：\nyield函数： 获取当前CPU所运行进程信息，并将其状态改成RUNNABLE，表明该进程之后会被运行，调用sched函数\nsched函数： 调用swtch函数，来保存当前CPU运行进程的context信息到进程的proc结构体中，并且从CPU调度进程中获取专属该CPU的context信息到寄存器中，有了该消息即可切换到CPU的调度进程\nswtch函数： swtch函数其实是由汇编实现的，其中就负责两件事情：保存和加载(save and load)，保存将当前的被调用者保存的寄存器放到当前进程的proc结构体中保存，而加载则是将CPU专属的context信息加载到被调用者保存的寄存器。\n此时一个合适的问题是下一步程序要怎么走？ 这得看ra寄存器(可能是return address?)保存的是什么了，其实这里是scheduler中的指令地址，在swtch ret指令之后pc就会取ra寄存器的指令地址\n上面一直说的CPU调度进程又是什么？ 实际上CPU调度进程是在main.c中调用的scheduler函数，这个进程在完成初始化之后就将执行一个不停止的for循环\nscheduler函数（线程安全）: scheduler函数会循环遍历，直到找到第一个可以运行的进程，此时同样需要一个swtch来保存当前的寄存器到cpu所属的CPU结构体的context中，并从可以运行的进程中加载context到寄存器，从而恢复进程的运行！\n至此便完成了一次完整的调度。实际上，上面的过程中最需要理解的就是切换寄存器就可以切换运行的进程！\n其实这里还有两个问题值得注意: 一个新进程是怎么运行起来的？ 首先被fork创建，初始化其state为RUNNABLE 调度器获取该进程的lock，并且通过swtch运行该进程，此时ra是swtch后的一个指令 对于一个全新的进程，此时scheduler第一次调度是返回到forkret这个函数，来完成一些初始化和锁的释放操作，随后再让这个新进程运行 锁是否会在调度中传递？ 对于一个旧进程，回到scheduler的时候其实是回到scheduler中swtch后的那个指令，且此时是带着锁（进程控制块的锁）回来的，因此需要在scheduler中释放锁。\n对于下一个进程而言，进程控制块的锁在scheduler中被设置，因此和整个流程是可以完整嵌合的（也就是说在swtch的时候锁的申请与释放并没有出现矛盾）。此时的内层for循环会从此刻位置开始继续往后找可运行的进程，不会出现进程设置成runnable之后又马上运行的情况，保证CPU的时间被所有线程均分！\n","date":"2023-12-26T21:12:07+08:00","permalink":"https://o-a-p.github.io/post/os/6.s081-os-scheduling/","section":"post","tags":null,"title":"6.S081：xv6 进程调度"},{"categories":["OS","6.S081"],"contents":" 2024-12-22 update 时隔一年，偶然看到一个相当好的回答：\n内核就是一个由interrupt驱动的程序。这个interrupt可以是一个系统调用（x86下，很多OS的系统调用是靠software interrupt实现的），可以是一个用户程序产生的异常，也可以是一个硬件产生的事件中断。 于是你的问题解决了：一个用户程序运行的时候，Linux就在内存里呆着，等着一个中断的到来。在这个中断的处理过程中，来做“调度”。 而一般的时分系统里，都会有个timer interrupt每隔一段时间到来，也就是楼上说的“时间片”。\n驱动是针对硬件的软件，中断是为了实现操作系统必要功能的方式。\nxv6介绍Interrupt的时候是借由数据键盘读取，屏幕显示来执行的，其中键盘和屏幕作为硬件输入输出设备是和uart芯片相连的，因此xv6软件中的读写是针对uart芯片驱动而言的，对于该芯片，xv6使用console这层抽象作为软件驱动（这里的console即使相当于把键盘和显示器分别作为输入输出设备的虚拟控制台而言的驱动），console的底层是uart驱动，两者相互配合完成读写、中断工作。 这里要分清楚什么是软件部分，什么是硬件部分，两者之间的交互关系又是如何。而这一部分的内容比较琐碎，因此分条列举：\n设备寄存器被映射到了内存地址，对这部分内存的读写会反映到设备上，这就是前面page table中kernel page table做的事情，当然也要与真正的硬件做一些配合\ndriver包含了两个part\ntop part，工作在内核环境下，负责软件主动的一些操作，例如该如何读（read），如何写（write），具体过程如下： read-\u0026gt;sys_read-\u0026gt;fileread-\u0026gt;devsw[].read（指定设备的read）-\u0026gt;consoleread（从内核缓存中读数据到用户空间，此处为cons.buf），此时就有个问题：谁把数据放到内核缓存中的？ wirte-\u0026gt;sys_write-\u0026gt;filewrite-\u0026gt;devsw[].write-\u0026gt;consolewrite（从用户空间读取数据到内核空间）-\u0026gt;uartputc（放到内核写缓存，此处为uart_tx_buf）-\u0026gt;uartstart（启动uart硬件） bottom part对于操作系统而言是被动的，当硬件完成任务后会借由PLIC（Platform-Level Interrupt Controller，根据优先级来分发路由中断）来向CPU发起中断请求，而CPU则会调用硬件驱动部分（console.c和uart.c）中的中断处理程序来进行一部分的中断处理。 当然中断不是唯一选项，对于一些变化速度比较快的设备还是轮询（polling）的策略比较好，当然目前的一些设备也有两者兼而有之的\n这些外设是如何初始化的？实际上从软件的视角来看，只能够直接沟通到UART硬件（芯片），该硬件是直接连接到键盘和显示器的，也就是所谓的console，因此我们不仅需要UART的驱动（uart.c）也需要console的驱动（console.c）\n在consoleinit()里调用uartinit()来初始化硬件，因为能够直接配置的硬件只有uart芯片。并且配置了console这个抽象硬件所对应的读写函数，此后所有针对console这个设备的读写都会被定位至特定的函数。 在uartinit()中打开两个中断：transmit and receive interrupts. 其中传输完成中断代表uart硬件已经完成了向外输出数据的任务，而receive中断则代表CPU需要处理外部数据 用户通过键盘（此时键盘是抽象的console的一部分）输入到console驱动读取并回显的过程：\n键盘输入，通过uart芯片接收并发起一个中断，陷入操作系统，进入trap过程 trampoline正常一套，进入usertrap函数 判断是外部中断引起的trap，此时通过devintr()函数对中断进行处理 通过plic_claim查询是哪个设备产生的中断 随后进入对应的处理流程进行处理，在此是uartintr()函数（因为是uart硬件中断，这里处理函数理应叫这个名字） 由于uart硬件发生中断有两种可能性（传输完成或者接收，也就是上面所说的两个中断） 需要从外部接收的情况则会从约定好的内存位置读取数据（即从外部寄存器读取），并交由专门的函数（consoleintr）进行处理，consoleintr负责将数据放到内核缓存，回显（具体的回显则是操作系统输出到屏幕上）和特殊字符处理 对于传输完成的情况（uart硬件完成了上次的传输任务，uart很空闲），则继续调用uartstart将buffer的数据传输出去 在consoleintr()中则是处理特殊字符，并将正确的字符放到输入缓存中，并且回显该字符到屏幕上，最后如果到达了一整行就唤醒之前在consoleread()中sleep的进程，来让之前睡眠的进程处理这些数据 针对设备的read系统调用则是会通过consoleread来进行处理，如果读buffer是空的，则需要sleep等待后面键盘输入将其唤醒，否则就从内核buffer复制到用户buffer\n软件的数据如果需要打印到屏幕上（或者说向抽象的console写数据）则是通过以下过程：\nwrite系统调用 因为在操作系统中所有外部设备都被视为文件，因此write会调用filewrite，而filewrite则会根据文件描述符（fd）来使用文件配套的函数（如果是正常文件就正常读写，如果是设备文件就用指定的读写函数，可见上面的3.1） 在该情况下，此时运行到了consolewrite函数，该函数从用户空间copyin数据，并通过uartputc将其传递给buffer里，然后启动uartstart uartstart则是直接将其写入寄存器，由uart硬件传递给正确的硬件 PLIC处理中断的具体流程：\n某个CPU运行plic_claim来获取一个中断来接收，而该中断则不会被其他CPU所处理 处理完成之后调用plic_complete来标识已经完成了该中断 ","date":"2023-12-25T20:43:45+08:00","permalink":"https://o-a-p.github.io/post/os/6.s081-os-interrupt/","section":"post","tags":null,"title":"6.S081：xv6 中断与驱动"},{"categories":null,"contents":"关于我 人物：苦逼找工仔，苦逼打工仔 技能：C/C++, CMake, Linux, GDB, Git, MySQL, Vue, Java, SpringBoot, Qt, Python 头像：https://pixel-me.tokyo/en/ 工作经历 2025.01 - Now 沉淀！用C++写游戏后台\n2024.05 - 2024.11 C++系统研发实习，量产项目自动驾驶系统功能逻辑层（Momenta Function Framework，MFF）开发，为表现层提供可靠数据，并控制自驾行车功能状态切换\n我偶尔会在这里刷新 关于本站 请各位在深色主题下阅览此博客，浅色太刺眼了，所以浅色主题适配只做了一点点，而且还整出来了一点主题切换的小bug，但也是特性，让大伙能够锁死在深色主题上🤗 相册懒加载不好使，加上本来就是白嫖GitHub，所以Photo加载会有点慢，理解万岁🙂 所有文章加起来约 59,570 字 相当于一本 《小王子》 友链 Mike 麦的视界 ","date":"2023-12-25T00:00:00Z","permalink":"https://o-a-p.github.io/about/","section":"","tags":null,"title":""},{"categories":["OS","6.S081"],"contents":" 在系统调用、中断以及异常（如page fault）时会陷入内核来执行处理。\n这里以系统调用为例。\n1. 以系统调用为例 一般先由进程调用一条系统调用的指令，在这里以第一个进程的ecall为例：\n1# user/initcode.S 2# exec(init, argv) 3.globl start 4start: 5 la a0, init 6 la a1, argv 7 li a7, SYS_exec 8 ecall 9 10# for(;;) exit(); 11exit: 12 li a7, SYS_exit 13 ecall 14 jal exit 15 16# char init[] = \u0026#34;/init\\0\u0026#34;; 17init: 18 .string \u0026#34;/init\\0\u0026#34; 19 20# char *argv[] = { init, 0 }; 21.p2align 2 22argv: 23 .long init 24 .long 0 上述过程已经足够清晰，这里的initcode.S的二进制编码早已在kernel/proc.c:userinit函数中作为数组被复制到第一个进程的内存中\n2. ecall探究！ ecall指令会使得硬件做一些事情：\necall工作 以上任务最主要的是：\n关闭中断 把pc复制到sepc用于恢复 scause保存trap原因 stvec（system trap vector）早已指向用户进程地址空间下的trampoline代码，将其复制给pc后，CPU要执行的即为trampoline中的第一行代码！此外，sscratch保存的是进程的p-\u0026gt;trapframe地址 在ecall执行后：\n进入trampoline.S后，执行的是uservec代码： 首先将a0和sscratch中的值交换，此时a0中的就是p-\u0026gt;trapframe的地址（sscratch寄存器是控制寄存器，不能作为基址寄存器） 随后将a0作为基址寄存器保存通用寄存器到trapframe中 随后保存sscratch中a0的值到trapframe 再然后依次从p-\u0026gt;trapframe中恢复kernel_sp，kernel_hartid，kernel_trap（即usertrap函数的地址），satp 上述数据恢复了之后跳转到usertrap函数中进行处理 kernel/trap.c:usertrap 在stvec中保存kernelvec函数的地址，因为此时已经在内核中，内核中的trap要用不同的函数处理 将sepc保存到trapframe的epc中（sepc是pc的值） 从scause中读取trap原因，分配不同的函数进行处理，此例中为syscall 首先将p-\u0026gt;trapframe-\u0026gt;epc加上4，因为之前指向ecall，此时需要它指向下一条指令来执行 打开中断，进行syscall系统调用 kernel/syscall.c:syscall 从a7寄存器中读出系统调用的标号，将其执行，并将返回值赋值给a0\nkernel/trap.c:usertrapret 开始返回过程 由于即将返回用户态，因此stvec中要塞入uservec的地址 将kernel satp，trap，kernel_sp，kernel_hartid的数据保存到trapframe中 从p-\u0026gt;trapframe-\u0026gt;epc中恢复pc的值到sepc中 恢复satp中的值为user pagetable 执行userret，从内核态返回用户态 kernel/trampoline.S:userret 恢复user pagetable 从trapframe中恢复寄存器的数据 保存trapframe的地址到sscratch中 sret返回用户态，并完成一系列的硬件操作 之后的很多实验都会需要爆改usertrap函数\n同理代码还是得debug一下才能知道这里怎么跑的，debug过程中从用户态跳到内核态是进不了trampoline的，此时得在stvec保存的地址处打个断点\n3. 参考 3.1 老哥1\n3.2 老哥2\n3.3 xv6 book\n","date":"2023-12-23T19:06:02+08:00","permalink":"https://o-a-p.github.io/post/os/6.s081-os-trap/","section":"post","tags":null,"title":"6.S081：xv6 trap过程"},{"categories":["OS","6.S081"],"contents":" 以下任务每个CPU都执行\n1. kernel/entry.S:_entry qemu使用0x80000000作为起始地址，_entry程序的任务是设置栈来使得xv6能够运行C代码（后续的C代码），因为初始没有栈的话即使是操作系统的C代码也不能执行（RISC-V的栈地址向下增长），现在可以运行C代码后，_entry调用kernel/start.c中的start程序。\n2. kernel/start.c:start 在Machine Mode模式下执行一些特定的寄存器配置，随后待用mret指令从M-Mode进入内核态，并且跳转到内核态的main.c中的main函数。（mret使用前提是上一次系统调用是从内核态到MM的，作用是从MM到内核态，虽然在启动过程没有这个前提，但通过设置一些变量和寄存器可以模拟这样的前提）\n以下任务只有CPU0执行，当然指的是初始化部分，后面的shell被哪个CPU执行都可能\n3. kernel/main.c:main 执行一些初始化工作如console初始化、内存映射、文件系统初始化，且保证只有一个cpu执行该工作（避免重复初始化），通过userinit()函数创建第一个用户进程\n4. kernel/proc.c:userinit init进程：分配第一个进程，初始化进程信息，最重要的是将initcode的硬编码的程序放到进程的虚拟地址的第一页，即执行initcode.S中的程序(在user/initcode.S汇编中定义)，随后设置该进程为RUNNABLE。其具体任务为：中执行exec，参数为init（init即为user/init.c）和argv，通过kernel/syscall.c:syscall进行执行（在syscall中打断点可以看到，num为7对应exec系统调用）\n5. user/initcode.S:start 第一步跳转（实际上不是跳转，直接把initcode.o的二进制硬编码然后复制到了内存里，让其被执行， initcode.S就是给人看的，另外走这个路径实际上是只有第一次会走，以后都是走usys的路径。当然从二进制的视角看的确也是跳转）至initcode.S即在4中要执行的程序，start程序负责设置一些参数，例如下一步要执行的程序（user/init.c）、参数列表、要执行的系统调用的编号（SYS_exec宏定义），最后通过ecall进入内核态执行exec程序（本质上是要执行user/init.c），在最终执行init之前，要先进入syscall函数\n6. kernel/syscall.c:syscall 进入syscall函数后就可以获取进程所要执行的系统调用的syscall num（原始定义在kernel/syscall.h中）,即通过syscalls[]数组获取要执行的指令，在此例中是exec，num为7，参数分别是/init和init，0（user/initcode.S）\n7. kernel/sysfile.c:sys_exec exec系统调用，将第一个进程覆盖，执行init.c中的程序\n实际上这里的第一个进程都是在scheduler之后进行的，通过CPU调度！\n8. user/init.c:main init进程（覆盖后）：真正的父进程，创建console设备，链接0，1，2文件描述符，打印信息，创建子进程启动shell，原进程负责回收子进程（wait系统调用）：\n1// init: The initial user-level program 2 3#include \u0026#34;kernel/types.h\u0026#34; 4#include \u0026#34;kernel/stat.h\u0026#34; 5#include \u0026#34;kernel/spinlock.h\u0026#34; 6#include \u0026#34;kernel/sleeplock.h\u0026#34; 7#include \u0026#34;kernel/fs.h\u0026#34; 8#include \u0026#34;kernel/file.h\u0026#34; 9#include \u0026#34;user/user.h\u0026#34; 10#include \u0026#34;kernel/fcntl.h\u0026#34; 11 12char *argv[] = { \u0026#34;sh\u0026#34;, 0 }; 13 14int 15main(void) 16{ 17 int pid, wpid; 18 19 if(open(\u0026#34;console\u0026#34;, O_RDWR) \u0026lt; 0){ 20 mknod(\u0026#34;console\u0026#34;, CONSOLE, 0); 21 open(\u0026#34;console\u0026#34;, O_RDWR); 22 } 23 dup(0); // stdout 24 dup(0); // stderr 25 26 for(;;){ 27 printf(\u0026#34;init: starting sh\\n\u0026#34;); 28 pid = fork(); 29 if(pid \u0026lt; 0){ 30 printf(\u0026#34;init: fork failed\\n\u0026#34;); 31 exit(1); 32 } 33 if(pid == 0){ 34 // 执行shell进程 35 exec(\u0026#34;sh\u0026#34;, argv); 36 printf(\u0026#34;init: exec sh failed\\n\u0026#34;); 37 exit(1); 38 } 39 // 在此处回收子进程 40 for(;;){ 41 // this call to wait() returns if the shell exits, 42 // or if a parentless process exits. 43 wpid = wait((int *) 0); 44 if(wpid == pid){ 45 // the shell exited; restart it. 46 break; 47 } else if(wpid \u0026lt; 0){ 48 printf(\u0026#34;init: wait returned an error\\n\u0026#34;); 49 exit(1); 50 } else { 51 // it was a parentless process; do nothing. 52 } 53 } 54 } 55} 9. 小结 实际上第一个系统调用是initcode中的ecall来调用exec，执行的是init.c中的程序，由init.c负责创建shell：\n硬编码进程调用exec执行init进程，init进程创建shell进程并负责回收子进程\n还是要让代码跑起来看看才清楚是怎么启动的~\n","date":"2023-12-20T20:12:49+08:00","permalink":"https://o-a-p.github.io/post/os/6.s081-os-start/","section":"post","tags":null,"title":"6.S081：xv6 启动过程"},{"categories":["OS","6.S081"],"contents":" 2023-7-10开始 2023-12-23搞定 还需要一个好点的总结，保证对所有知识都融会贯通，加油吧 搞完看一下jyy的课，常读常新 lab代码 1. Lab1 1.1 配置项目环境 照着这个或者这个搭建一遍就OK，此外要跑测试的话可能会找不到python环境，配置一下软链接就行，记住一定要用fetch再git checkout lab_name的方式建立，不要自己建立新的branch，一些文件可能会存在问题！！！\n1.2 配置编码环境 项目是使用makefile进行组织编译的，采用交叉编译，如果直接用vscode打开则不能跳转函数，不大方便，可以看jyy视频通过bear工具生成compile_commands.json文件，随后配置插件使之能够加载这个文件，从而可以保证函数跳转。但vscode用起来还是不舒服，配文件啥的很麻烦，我采用的方案是使用clion远程链接wsl（其实本地也能打开这个项目文件，但是解析compile_commands.json的时候由于路径是wsl路径所以会出问题，因此使用remote方案），首先bear make qemu编译完成后退出，生成compile_commands.json文件，clion选择打开即可，打开的时候要选择compilation database项目，如此就可以随便跳转了，其他可以参考一下这个使clion支持makefile项目。 妈的现在发现clion连wsl写中文注释会出现代码高亮失效的情况，而且卡得一批，还是用vscode+clangd组合吧，参考这个，注意.h文件有问题得自己手动搞，.clang-format参考这个老哥的\n1.3 系统调用 all syscall 1.4 sleep 使用系统调用int sleep(int)封装一下就行，最终还是使用汇编来调用kernel层中最基础的sys_sleep，注意特殊情况如的处理。另外还需要注意，C语言整个编译过程要保证定义只有一次，这里想用user/ulib.c中的atoi函数，导入ulib.c会造成重复编译，直接在文件里声明atoi函数即可。写完之后要在Makefile里加上对应的文件名。代码如下：\n1#include \u0026#34;kernel/types.h\u0026#34; 2#include \u0026#34;kernel/stat.h\u0026#34; 3#include \u0026#34;user/user.h\u0026#34; 4 5int atoi(const char *s); 6 7int main(int argc, char *argv[]) 8{ 9 if (argc \u0026lt;= 1) 10 { 11 fprintf(2, \u0026#34;sleep: please set up sleep time\\n\u0026#34;); 12 exit(1); 13 } 14 if (argc \u0026gt; 2) 15 { 16 fprintf(2, \u0026#34;sleep: too many arguments\\n\u0026#34;); 17 exit(1); 18 } 19 sleep(atoi(argv[1])); 20 exit(0); 21} 1.5 pingpong 要知道，pipe可以在进程间通信，随后只需要两个pipe，一个负责从父进程向子进程传输数据，一个负责从子进程向父进程传输数据，先写后读，关闭对应的pipe端即可。代码如下：\n1#include \u0026#34;kernel/types.h\u0026#34; 2#include \u0026#34;user/user.h\u0026#34; // fork 3 4int main(int argc, char *argv[]) 5{ 6 char buffer[5]; 7 if (argc \u0026gt; 1) 8 { 9 fprintf(2, \u0026#34;pingpong: too many arguments\u0026#34;); 10 } 11 int parent_to_child[2]; 12 int child_to_parent[2]; 13 // trans data from parent to child 14 pipe(parent_to_child); 15 // trans data from child to parent 16 pipe(child_to_parent); 17 18 if (fork() == 0) 19 { 20 // child process 21 // close write end of parent to child; 22 close(parent_to_child[1]); 23 // close read en of child to parent; 24 close(child_to_parent[0]); 25 write(child_to_parent[1], \u0026#34;pong\\n\u0026#34;, 5); 26 // close write end of child to parent 27 close(child_to_parent[1]); 28 read(parent_to_child[0], buffer, sizeof(buffer)); 29 // close read end of parent to child 30 close(parent_to_child[1]); 31 printf(\u0026#34;%d: received \u0026#34;, getpid()); 32 write(1, buffer, 5); 33 } 34 else 35 { 36 // parent process 37 // close read end of parent to child 38 close(parent_to_child[0]); 39 // close write end of child to parent 40 close(child_to_parent[1]); 41 write(parent_to_child[1], \u0026#34;ping\\n\u0026#34;, 5); 42 // close write end of parent to child 43 close(parent_to_child[1]); 44 read(child_to_parent[0], buffer, sizeof(buffer)); 45 // close read end of child to parent 46 close(child_to_parent[0]); 47 printf(\u0026#34;%d: received \u0026#34;, getpid()); 48 write(1, buffer, 5); 49 } 50 exit(0); 51} 1.6 primes 首先还得看懂教程提示：从2-35依次送往pipe读端，然后循环创建进程处理每一次丢弃后的数据。此外，要时刻记住三件事：\n把握数据的流向 关闭不用的pipe的所有的读端和写端，否则会阻塞 数据在pipe中是单向流动的 代码如下： 1#include \u0026#34;kernel/types.h\u0026#34; 2#include \u0026#34;kernel/stat.h\u0026#34; 3#include \u0026#34;user/user.h\u0026#34; 4 5void prime(int read_pipe, int write_pipe, int divider) 6{ 7 int num; 8 while (read(read_pipe, \u0026amp;num, sizeof(int)) != 0) 9 { 10 if (num % divider != 0) 11 { 12 write(write_pipe, \u0026amp;num, sizeof(int)); 13 } 14 } 15 close(read_pipe); 16 close(write_pipe); 17 18 exit(0); 19} 20 21#define MAX 35 22 23int main() 24{ 25 int p[2]; 26 pipe(p); 27 28 if (fork() == 0) 29 { 30 close(p[0]); 31 // child process 0: write all number to pipe 32 for (int i = 2; i \u0026lt;= MAX; i++) 33 { 34 write(p[1], \u0026amp;i, sizeof(int)); 35 } 36 close(p[1]); 37 exit(0); 38 } 39 40 int num; 41 int read_pipe = p[0]; 42 int write_pipe; 43 close(p[1]); 44 45 while (read(read_pipe, \u0026amp;num, sizeof(int)) != 0) 46 { 47 int p_next[2]; 48 pipe(p_next); 49 write_pipe = p_next[1]; 50 51 if (fork() == 0) 52 { 53 // child process 54 printf(\u0026#34;prime %d\\n\u0026#34;, num); 55 // read data and send prime to the next pipe 56 prime(read_pipe, write_pipe, num); 57 close(read_pipe); 58 close(write_pipe); 59 close(p_next[0]); 60 // close this process 61 exit(0); 62 } 63 else 64 { 65 // father process 66 close(read_pipe); 67 close(write_pipe); 68 read_pipe = p_next[0]; 69 } 70 } 71 // father: close read end 72 close(read_pipe); 73 wait(0); 74 exit(0); 75} 1.7 find 写一个find函数，真是踩了太多坑了，一开始写出来了，但是不清楚为什么需要按一下回车才能执行结果，苦苦debug了很久，gdb也有bug，明明在find.c的main打的断点，用一下ls居然也触发了，真是吃屎。最后灵感迸发，把while里面的if的判断条件换了个位置就可以不用按回车了。 解决思路也很简单，先判断是目录还是文件，是文件就对比，是目录就递归调用，这里需要注意：\n有时候测试卡住了跑一下make clean就可以 注意./gdb_init里的端口设置，保证能够连接 注意端口占用，有时候会有程序不知不觉占用25000端口导致gdb不可用 注意函数的行为，如fstat、stat、strlen、strcpy、strcmp等函数的行为 一些边界情况也要写全，不要不写 makefile和gdb等工具还是要学一下，不然一大堆事情 代码如下： 1#include \u0026#34;kernel/types.h\u0026#34; 2#include \u0026#34;kernel/stat.h\u0026#34; 3#include \u0026#34;user/user.h\u0026#34; 4#include \u0026#34;kernel/fs.h\u0026#34; 5 6// recusively find file_name in path 7// path is directory by default 8void find(char* path, char* file_name) 9{ 10 char buf[512], *p; 11 int fd; // file descriptor 12 struct stat st; 13 struct dirent de; 14 if ((fd = open(path, 0)) \u0026lt; 0) 15 { 16 fprintf(2, \u0026#34;find: cannot open %s\\n\u0026#34;, path); 17 return; 18 } 19 if (fstat(fd, \u0026amp;st) \u0026lt; 0) 20 { 21 fprintf(2, \u0026#34;find: cannot open %s\\n\u0026#34;, path); 22 close(fd); 23 return; 24 } 25 if(st.type == T_FILE) 26 { 27 fprintf(2, \u0026#34;find: please enter directory path\\n\u0026#34;); 28 close(fd); 29 return; 30 } 31 if(strlen(path) + 1 + DIRSIZ + 1 \u0026gt; sizeof buf) 32 { 33 printf(\u0026#34;find: path too long\\n\u0026#34;); 34 close(fd); 35 return; 36 } 37 strcpy(buf, path); 38 p = buf + strlen(buf); 39 *p++ = \u0026#39;/\u0026#39;; 40 // read from directory，every time read a dirent 41 while (read(fd, \u0026amp;de, sizeof(de)) == sizeof(de)) 42 { 43 if((de.inum == 0) || (strcmp(de.name, \u0026#34;.\u0026#34;) == 0) || (strcmp(de.name, \u0026#34;..\u0026#34;) == 0)) 44 continue; 45 memmove(p, de.name, DIRSIZ); 46 p[DIRSIZ] = 0; // add end mark 47 if(stat(buf, \u0026amp;st) \u0026lt; 0) 48 { 49 printf(\u0026#34;ls: cannot stat %s\\n\u0026#34;, buf); 50 continue; 51 } 52 if (st.type == T_DIR) 53 { 54 // if path is a directory, continue to recursion 55 find(buf, file_name); 56 } 57 else 58 { 59 // if path is a file, then compare it with file name 60 if (strcmp(de.name, file_name) == 0) 61 { 62 fprintf(1, \u0026#34;%s\\n\u0026#34;, buf); 63 continue; 64 } 65 } 66 } 67 close(fd); 68 return; 69 // exit(0); 70} 71 72int main(int argc, char *argv[]) 73{ 74 if (argc \u0026lt; 3) 75 { 76 fprintf(2, \u0026#34;find: please enter enough arguments\\n\u0026#34;); 77 exit(1); 78 } 79 if (argc \u0026gt; 3) 80 { 81 fprintf(2, \u0026#34;find: too many arguments\\n\u0026#34;); 82 exit(1); 83 } 84 find(argv[1], argv[2]); 85 exit(0); 86} 1.8 xargs xargs是拿到上一个指令的输出，并且按照一定的规则（-n）塞给下一个指定程序（作为xargs的参数），如：\nxargs示例 注意获取数据是从标准输入获取，因为不知道大小只能获取一个字符，如果获取到了换行符则认为是一组参数，很简单，用到了一点K\u0026amp;R的读取技巧。随后使用fork和exec进行执行，非常简单，完整代码如下：\n1#include \u0026#34;kernel/types.h\u0026#34; 2#include \u0026#34;kernel/stat.h\u0026#34; 3#include \u0026#34;user/user.h\u0026#34; 4#include \u0026#34;kernel/param.h\u0026#34; 5 6int main(int argc, char *argv[]) 7{ 8 char *argv_real[MAXARG]; 9 char tmp = 0; 10 char arg[MAXARG]; // store arg passed by pipe 11 int index = 0; 12 13 if (argc \u0026lt; 2) 14 { 15 fprintf(2, \u0026#34;xargs: more arguments required!\u0026#34;); 16 } 17 if (argc \u0026gt; MAXARG - 1) 18 { 19 fprintf(2, \u0026#34;xargs: too many arguments!\u0026#34;); 20 } 21 22 for (int i = 0; i \u0026lt; argc - 1; i++) 23 { 24 argv_real[i] = argv[i + 1]; 25 } 26 27 while (read(0, \u0026amp;tmp, sizeof(tmp)) != 0) 28 { 29 if (index == MAXARG - 1) 30 { 31 fprintf(2, \u0026#34;xargs: argument is too long\u0026#34;); 32 } 33 if (tmp != \u0026#39;\\n\u0026#39;) 34 { 35 arg[index++] = tmp; 36 } 37 else 38 { 39 arg[index] = \u0026#39;\\0\u0026#39;; 40 index = 0; 41 // fork and exec 42 if (fork() == 0) 43 { 44 argv_real[argc - 1] = arg; 45 exec(argv_real[0], argv_real); 46 exit(0); 47 } 48 else 49 { 50 // wait for child process 51 wait(0); 52 } 53 } 54 } 55 exit(0); 56} 2. Lab2 2.1 sys_trace 设计一个sys_trace系统调用，这里有很多需要注意的地方，首先是执行流程：\n在user.h添加一个void trace(int)的函数原型，然后在usys.pl中添加entry(\u0026ldquo;trace\u0026rdquo;)，usys.pl会通过脚本生成一堆汇编代码(user/usys.S)，生成下面这段代码： 1.global trace 2trace: 3 li a7, SYS_trace 4 ecall 5 ret 作用就是声明一个全局的代码段，当trace函数被调用时，执行该程序，该程序将SYS_trace（一个由kernel/syscall.h中定义的宏）传入到a7中，随后执行ecall，ecall的含义比较复杂，暂且不知道，但一点是肯定的，它会带着数据执行syscall！\necall则会整理数据后跳转到syscall函数(kernel/syscall.c)，根据SYS_trace决定执行数组中的对应的函数，在此例中则是sys_trace系统调用（kernel/sysproc.c）\n在sys_trace系统调用中采用argint函数获取trace函数传入的参数，并将其赋值给trace_mask（kernel/proc.h），系统调用执行完毕后返回syscall打印题目要求的输出。\n执行流程有点麻烦，其中最让人疑惑的就是参数从trace传递到sys_trace，目前不知道用了什么手段，但应该是把数据存在某些地方。 具体来说要做的事情有：\n在user/user.h中添加trace函数的原型： 1int trace(int); // 返回值要和sys_trace保持一致，输入不用 在kernel/syscall.h中添加宏定义，即系统调用的标号 1#define SYS_trace 22 在user/usys.pl中添加entry，建立trace和SYS_trace的关联 1entry(\u0026#34;trace\u0026#34;); 在kernel/sysproc.c中添加sys_trace函数，函数原型要与其他函数保持一致，便于syscall统一调用 1uint64 sys_trace(void) 2{ 3 int mask; 4 if (argint(0, \u0026amp;mask) \u0026lt; 0) // 这里不太明白从哪里读的 5 { 6 return -1; 7 } 8 // set trace mask 9 struct proc *p = myproc(); 10 p-\u0026gt;trace_mask = mask; 11 12 return 0; 13} 在kernel/syscall.c的函数数组中添加[SYS_trace] sys_trace，并在前面加上extern声明，这是C的语法，指定下标元素的值；添加id与名字对应的数组： 1const char *syscall_name[] = { 2 [SYS_fork] \u0026#34;fork\u0026#34;, 3 [SYS_exit] \u0026#34;exit\u0026#34;, 4 [SYS_wait] \u0026#34;wait\u0026#34;, 5 [SYS_pipe] \u0026#34;pipe\u0026#34;, 6 [SYS_read] \u0026#34;read\u0026#34;, 7 [SYS_kill] \u0026#34;kill\u0026#34;, 8 [SYS_exec] \u0026#34;exec\u0026#34;, 9 [SYS_fstat] \u0026#34;fstat\u0026#34;, 10 [SYS_chdir] \u0026#34;chdir\u0026#34;, 11 [SYS_dup] \u0026#34;dup\u0026#34;, 12 [SYS_getpid] \u0026#34;getpid\u0026#34;, 13 [SYS_sbrk] \u0026#34;sbrk\u0026#34;, 14 [SYS_sleep] \u0026#34;sleep\u0026#34;, 15 [SYS_uptime] \u0026#34;uptime\u0026#34;, 16 [SYS_open] \u0026#34;open\u0026#34;, 17 [SYS_write] \u0026#34;write\u0026#34;, 18 [SYS_mknod] \u0026#34;mknod\u0026#34;, 19 [SYS_unlink] \u0026#34;unlink\u0026#34;, 20 [SYS_link] \u0026#34;link\u0026#34;, 21 [SYS_mkdir] \u0026#34;mkdir\u0026#34;, 22 [SYS_close] \u0026#34;close\u0026#34;, 23 [SYS_trace] \u0026#34;trace\u0026#34;, 24}; 在kernel/proc.h中添加trace_mask来记录数据 1// Per-process state 2struct proc { 3 struct spinlock lock; 4 5 // p-\u0026gt;lock must be held when using these: 6 enum procstate state; // Process state 7 struct proc *parent; // Parent process 8 void *chan; // If non-zero, sleeping on chan 9 int killed; // If non-zero, have been killed 10 int xstate; // Exit status to be returned to parent\u0026#39;s wait 11 int pid; // Process ID 12 13 int trace_mask; 14 15 // these are private to the process, so p-\u0026gt;lock need not be held. 16 uint64 kstack; // Virtual address of kernel stack 17 uint64 sz; // Size of process memory (bytes) 18 pagetable_t pagetable; // User page table 19 struct trapframe *trapframe; // data page for trampoline.S 20 struct context context; // swtch() here to run process 21 struct file *ofile[NOFILE]; // Open files 22 struct inode *cwd; // Current directory 23 char name[16]; // Process name (debugging) 24}; 在kernel/syscall.c中的syscall函数中添加行为，检测当前系统调用和开启trace的系统调用是否一致，如果一致则打印信息： 1void syscall(void) 2{ 3 int num; 4 struct proc *p = myproc(); 5 6 num = p-\u0026gt;trapframe-\u0026gt;a7; 7 if (num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) 8 { 9 p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); 10 11 if ((p-\u0026gt;trace_mask \u0026amp; (1 \u0026lt;\u0026lt; num)) != 0) 12 { 13 // open trace 14 printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;, p-\u0026gt;pid, syscall_name[num], p-\u0026gt;trapframe-\u0026gt;a0); 15 } 16 } 17 else 18 { 19 printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, 20 p-\u0026gt;pid, p-\u0026gt;name, num); 21 p-\u0026gt;trapframe-\u0026gt;a0 = -1; 22 } 23} 在user中添加trace.c文件来执行： 1#include \u0026#34;kernel/types.h\u0026#34; 2#include \u0026#34;kernel/stat.h\u0026#34; 3#include \u0026#34;user/user.h\u0026#34; 4#include \u0026#34;kernel/param.h\u0026#34; 5 6int main(int argc, char *argv[]) 7{ 8 if (argc \u0026lt; 2) 9 { 10 fprintf(2, \u0026#34;trace: wrong number of arguments!\\n\u0026#34;); 11 exit(1); 12 } 13 14 int mask = atoi(argv[1]); 15 char *argv_real[MAXARG]; 16 17 trace(mask); 18 19 for (int i = 0; i \u0026lt; argc - 2; i++) 20 { 21 argv_real[i] = argv[i + 2]; 22 } 23 24 if (fork() == 0) 25 { 26 exec(argv_real[0], argv_real); 27 } 28 else 29 { 30 wait(0); 31 } 32 exit(0); 33} 还有一些关于debug的部分比较重要，网友解释，主要是要了解gdb是通过file操作来读取最终生成的可执行文件或者说ELF（Executable and Linkable Format），后续的所有打断点都是基于ELF文件来的，有时候解释不了就没有办法打断点。\n2.2 sys_sysinfo 妈的这个系统调用一定要叫sysinfo，不然会出错\n还是和上个实验一样增加一些前置定义 主要目的是统计free memory和used process，那么第一步就是寻找free memory的数量，根据提示可以在kernel/kalloc.c中看到kalloc函数，里面有个kmem的结构体，freelist应该就是链表，存储所有空闲的pagesize的内存，指向的地方是空闲的4096大小的内存的首地址，那么后续就和普通链表操作一样，统计一共有多少page： 1// return free memory in bytes 2uint64 get_free_memory(void) 3{ 4 struct run *r; 5 6 uint64 count = 0; 7 acquire(\u0026amp;kmem.lock); 8 r = kmem.freelist; 9 while (r) 10 { 11 r = r-\u0026gt;next; 12 ++count; 13 } 14 release(\u0026amp;kmem.lock); 15 return count * PGSIZE; 16} 下一步是找到已经使用的进程的数量，根据提示可以在kernel/proc.c中看到一个allocproc的函数，里面的行为正是从proc数组中获取状态，如果不是UNUSED那么就将其纳入统计，代码如下： 1// get processes whose state is not UNUSED 2uint64 get_used_process(void) 3{ 4 struct proc *p; 5 uint64 count = 0; 6 for (p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) 7 { 8 acquire(\u0026amp;p-\u0026gt;lock); 9 if (p-\u0026gt;state != UNUSED) 10 { 11 ++count; 12 } 13 release(\u0026amp;p-\u0026gt;lock); 14 } 15 return count; 16} 写sys_sysinfo系统调用，这里面要尤其注意，获取的参数是地址，但这个地址实际上是用户态的栈空间中的地址，内核态时似乎不允许直接访问，这里需要先获取用户空间中sysinfo结构体的地址，再构建一个临时的sysinfo对象存储数据，再使用copyout函数从内核空间将数据复制到用户空间，代码如下： 1extern uint64 get_free_memory(void); 2extern uint64 get_used_process(void); 3 4uint64 sys_sysinfo(void) 5{ 6 uint64 info; 7 struct sysinfo p_sysinfo; 8 9 struct proc *p = myproc(); 10 // 这里获取的info是用户空间的虚拟地址，直接读写根本就不行，因为此时在内核空间，很容易搞崩 11 if (argaddr(0, \u0026amp;info) \u0026lt; 0) 12 { 13 return -1; 14 } 15 16 p_sysinfo.freemem = get_free_memory(); 17 p_sysinfo.nproc = get_used_process(); 18 // pagetable就是用户空间的数据，info则是虚拟目标地址，第三个则是源地址（内核空间），第四个就是需要复制的字节数量！ 19 if (copyout(p-\u0026gt;pagetable, info, (char *)\u0026amp;p_sysinfo, sizeof(p_sysinfo)) \u0026lt; 0) 20 { 21 return -1; 22 } 23 return 0; 24} 这里一定一定要注意，用户空间和内核空间的地址不是一样的，在内核态访问用户空间的地址会直接把内核搞崩溃！\n3. Lab3 3.1 vmprint 实现一个vmprint的函数，遍历三层page_table树\n在kernel/vm.c中增加vmprint函数，首先打印该地址，随后遍历打印三层 1void vmprint(pagetable_t pagetable) 2{ 3 printf(\u0026#34;page table %p\\n\u0026#34;, pagetable); 4 vmprint_recursively(pagetable, 1); 5} 遍历函数实现，本质上就是循环加遍历，CS106B有用的，抄一下freewalk函数就OK 1void vmprint_recursively(pagetable_t pagetable, int depth) 2{ 3 for (int i = 0; i \u0026lt; 512; i++) 4 { 5 pte_t pte = pagetable[i]; 6 if (pte \u0026amp; PTE_V) 7 { 8 for (int j = 0; j \u0026lt; depth; j++) 9 { 10 if (j == 0) 11 { 12 printf(\u0026#34;..\u0026#34;); 13 } 14 else 15 { 16 printf(\u0026#34; ..\u0026#34;); 17 } 18 } 19 printf(\u0026#34;%d: pte %p pa %p\\n\u0026#34;, i, pte, PTE2PA(pte)); 20 if ((pte \u0026amp; (PTE_R | PTE_W | PTE_X)) == 0) 21 { 22 vmprint_recursively((pagetable_t)PTE2PA(pte), depth + 1); 23 } 24 } 25 } 26} 在kernel/defs.h中增加vmprint声明，在exec.c/exec中调用 1if (p-\u0026gt;pid == 1) 2 vmprint(p-\u0026gt;pagetable); 这个实验倒是很简单，主要思路在freewalk函数里就有。\n3.2 A kernel page table per process 其实这个实验是和下一个实验进行配合，对内核进行一点魔改，自始至终xv6都是通过SATP寄存器存储pagetable，进而对虚拟内存进行寻址找出真正的地址，在内核态SATP存储kernel pagetable而在用户态存储每个进程的pagetable即user pagetable，也就是说内核有pagetable，进程也有pagetable。这种情况就会造成用户态的地址在进入内核态后没用，因此这部分实验和后面的一个实验就是让每个进程都有一份kernel pagetable，进入内核态时不再使用全局的kernel pagetable，而是使用自己的，来达到让每个进程都能够便捷的使用自己的虚拟内存。\n内核也是C程序，只不过是用来管理其他程序的C程序，一方面提供一些系统调用的接口，来使得其他程序能够便捷地与硬件沟通，另一方面还要管理其他程序的生命周期，为程序分配进程，回收进程。在分配方面，exec程序很重要，这个程序读取并检查可执行文件了ELF头，将程序加载进内存替换当前的进程的数据\n在kernel/proc.h中的proc结构体中增加字段kernel_pagetable，用来映射内核 1// Per-process state 2struct proc { 3 struct spinlock lock; 4 5 // p-\u0026gt;lock must be held when using these: 6 enum procstate state; // Process state 7 struct proc *parent; // Parent process 8 void *chan; // If non-zero, sleeping on chan 9 int killed; // If non-zero, have been killed 10 int xstate; // Exit status to be returned to parent\u0026#39;s wait 11 int pid; // Process ID 12 13 // these are private to the process, so p-\u0026gt;lock need not be held. 14 uint64 kstack; // Virtual address of kernel stack 15 uint64 sz; // Size of process memory (bytes) 16 pagetable_t pagetable; // User page table 17 pagetable_t kernel_pagetable;// lab 3 18 struct trapframe *trapframe; // data page for trampoline.S 19 struct context context; // swtch() here to run process 20 struct file *ofile[NOFILE]; // Open files 21 struct inode *cwd; // Current directory 22 char name[16]; // Process name (debugging) 23}; 对于每个进程都需要一份kernel pagetable，因此需要一个函数来执行和kvminit函数相似的功能，本质上这就是对同一份物理地址进行多次映射，也就是说有多份虚拟地址指向同一份物理地址： 1pagetable_t get_kpt() 2{ 3 pagetable_t kpt = (pagetable_t) kalloc(); 4 if (kpt == 0) { 5 return 0; 6 } 7 memset(kpt, 0, PGSIZE); 8 ukvmmap(kpt, UART0, UART0, PGSIZE, PTE_R | PTE_W); 9 ukvmmap(kpt, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); 10 ukvmmap(kpt, CLINT, CLINT, 0x10000, PTE_R | PTE_W); 11 ukvmmap(kpt, PLIC, PLIC, 0x400000, PTE_R | PTE_W); 12 ukvmmap(kpt, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); 13 ukvmmap(kpt, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); 14 ukvmmap(kpt, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); 15 return kpt; 16} 有了函数之后还需要在kernel/proc.c中的allocproc函数中进行调用，这个函数负责找出未使用的进程并返回，并且对这个进程struct来进行一些初始化（这玩意应该就是进程控制块），包括初始化kernel pagetable。 1static struct proc* 2allocproc(void) 3{ 4... 5 // An empty user page table. 6 p-\u0026gt;pagetable = proc_pagetable(p); 7 if(p-\u0026gt;pagetable == 0){ 8 freeproc(p); 9 release(\u0026amp;p-\u0026gt;lock); 10 return 0; 11 } 12 13 // 这里就相当于初始化了 14 p-\u0026gt;kernel_pagetable = get_kpt(); 15 if (p-\u0026gt;kernel_pagetable == 0) 16 { 17 freeproc(p); 18 release(\u0026amp;p-\u0026gt;lock); 19 return 0; 20 } 21... 22} 在kernel/proc.c:procinit函数中会负责映射全局的kernel pagetable中的针对每个进程的kstack，因此在进程的kernel pagetable中也至少要映射自己，同样需要一个函数来实现这个过程 // map kernel pagetable per process with pa void ukvmmap(pagetable_t kpt, uint64 va, uint64 pa, uint64 sz, int perm) { if (mappages(kpt, va, sz, pa, perm) != 0) panic(\u0026ldquo;ukvmmap\u0026rdquo;); } 此时还需要在kernel/proc.c:allocproc中调用这个函数，调用之前要保证先有物理内存 1static struct proc* 2allocproc(void) 3{ 4... 5 // 这里就相当于初始化了 6 p-\u0026gt;kernel_pagetable = get_kpt(); 7 if (p-\u0026gt;kernel_pagetable == 0) 8 { 9 freeproc(p); 10 release(\u0026amp;p-\u0026gt;lock); 11 return 0; 12 } 13 // 同时也整了块内存来放kstack，这个kstack实际上是自己的 14 char *pa = kalloc(); 15 if (pa == 0) 16 panic(\u0026#34;allocproc: kalloc\u0026#34;); 17 uint64 va = KSTACK((int)(p - proc)); 18 ukvmmap(p-\u0026gt;kernel_pagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); 19 // 这个时候p-\u0026gt;kstack指的就是kpt中的地址了 20 p-\u0026gt;kstack = va; 21... 22} 现在初始化这个kernel pagetable已经完成了，但还需要在合适的地方使用这个东西（SATP寄存器），需要在kernel/proc.c:scheduler函数中对其进行调用，同时，如果没有进程被使用那么就可以直接调用全局的内核页表 1void 2scheduler(void) 3{ 4 struct proc *p; 5 struct cpu *c = mycpu(); 6 7 c-\u0026gt;proc = 0; 8 for(;;){ 9 // Avoid deadlock by ensuring that devices can interrupt. 10 intr_on(); 11 12 int found = 0; 13 for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { 14 acquire(\u0026amp;p-\u0026gt;lock); 15 if(p-\u0026gt;state == RUNNABLE) { 16 // Switch to chosen process. It is the process\u0026#39;s job 17 // to release its lock and then reacquire it 18 // before jumping back to us. 19 p-\u0026gt;state = RUNNING; 20 c-\u0026gt;proc = p; 21 w_satp(MAKE_SATP(p-\u0026gt;kernel_pagetable)); 22 sfence_vma(); 23 swtch(\u0026amp;c-\u0026gt;context, \u0026amp;p-\u0026gt;context); 24 25 // Process is done running for now. 26 // It should have changed its p-\u0026gt;state before coming back. 27 c-\u0026gt;proc = 0; 28 29 found = 1; 30 } 31 release(\u0026amp;p-\u0026gt;lock); 32 } 33#if !defined (LAB_FS) 34 if(found == 0) { 35 intr_on(); 36 w_satp(MAKE_SATP(kernel_pagetable)); 37 sfence_vma(); 38 asm volatile(\u0026#34;wfi\u0026#34;); 39 } 40#else 41 ; 42#endif 43 } 44} 有了初始化，有了使用，下一个很自然的想法就是应该释放掉，毕竟内存是通过alloc来的，在free之前可以看看初始化的时候想想有哪些需要free的： 初始化的时候申请了一页kstack，那么这个需要被free掉 进程的内核页表本身用了一些空间来存储多级页表（在walk的时候分配的） 因此需要free以上这些东西，free kstack内存是很简单的，但是多级页表很麻烦，且不能free掉最终的物理内存，因为有其他的进程还在使用，所以需要一个函数来执行这个过程，实现需要参考freewalk函数，但切记不能free掉最终的物理内存。这里要注意，最后一级页表的RWX位肯定有一个为1，因此可以通过该种手段来判断是不是最后一级页表。（但感觉freewalk也是这么做的，感觉能直接用freewalk） 1void proc_freekpt(pagetable_t kpt) 2{ 3 // kpt中有什么需要被free的？ 4 // 无非是之前map的pa，但pa又不是freelist管理的，因此没有必要去清除 5 for (int i = 0; i \u0026lt; 512; i++) 6 { 7 pte_t pte = kpt[i]; 8 // 该pte是有效的，可以被访问 9 if (pte \u0026amp; PTE_V) 10 { 11 kpt[i] = 0; 12 // 这代表当前页表项b 13 if ((pte \u0026amp; (PTE_R | PTE_W | PTE_X)) == 0) 14 { 15 uint64 child = PTE2PA(pte); 16 proc_freekpt((pagetable_t)child); 17 } 18 } 19 } 20 kfree((void *)kpt); 21} 因此最后只需要在freeproc函数中增加两部分即可\n1static void 2freeproc(struct proc *p) 3{ 4 if(p-\u0026gt;trapframe) 5 kfree((void*)p-\u0026gt;trapframe); 6 p-\u0026gt;trapframe = 0; 7 // 删除kernel stack 8 if (p-\u0026gt;kstack) 9 { 10 pte_t *pte = walk(p-\u0026gt;kernel_pagetable, p-\u0026gt;kstack, 0); 11 if (pte == 0) 12 panic(\u0026#34;freeproc: kstack\u0026#34;); 13 kfree((void *)PTE2PA(*pte)); 14 } 15 if(p-\u0026gt;pagetable) 16 proc_freepagetable(p-\u0026gt;pagetable, p-\u0026gt;sz); 17 // 删除kernel pagetable 18 if (p-\u0026gt;kernel_pagetable) 19 proc_freekpt(p-\u0026gt;kernel_pagetable); 20 p-\u0026gt;pagetable = 0; 21 p-\u0026gt;sz = 0; 22 p-\u0026gt;pid = 0; 23 p-\u0026gt;parent = 0; 24 p-\u0026gt;name[0] = 0; 25 p-\u0026gt;chan = 0; 26 p-\u0026gt;killed = 0; 27 p-\u0026gt;xstate = 0; 28 p-\u0026gt;state = UNUSED; 29} 实际上还有最后一个地方需要更改，那就是kvmpa函数，这里想办法让它使用process的页表 1uint64 2kvmpa(uint64 va) 3{ 4 uint64 off = va % PGSIZE; 5 pte_t *pte; 6 uint64 pa; 7 8 pte = walk(myproc()-\u0026gt;kernel_pagetable, va, 0); 9 if(pte == 0) 10 panic(\u0026#34;kvmpa\u0026#34;); 11 if((*pte \u0026amp; PTE_V) == 0) 12 panic(\u0026#34;kvmpa\u0026#34;); 13 pa = PTE2PA(*pte); 14 return pa+off; 15} 3.3 Simplify copyin/copyinstr 3.2和3.2是搭配起来的，上面已经想办法让每个process都有自己的kernel pagetable，但这玩意没啥用，想要它真正起作用来达到在内核态时直接可以用虚拟地址就得想办法把每个process的pagetable映射到其kernel pagetable上，比上一个实验简单。这里需要做到的事情只有两件：\n把pagetable映射到kernel pagetable，根据hints可以知道可以在不超过PLIC(0xc000000)的地方映射pagetable，毕竟虚拟内存从0开始，参考uvmcopy函数的实现，魔改一个自己的函数就行，注意这里需要install ptes而不是去mappage，同时要记住清除标志位。 1void 2uvmkptcopy(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz) 3{ 4 pte_t *pte_from, *pte_to; 5 uint64 a, pa; 6 uint flags; 7 8 if (newsz \u0026lt; oldsz) 9 return; 10 11 oldsz = PGROUNDUP(oldsz); 12 for (a = oldsz; a \u0026lt; newsz; a += PGSIZE) 13 { 14 if ((pte_from = walk(pagetable, a, 0)) == 0) 15 panic(\u0026#34;u2kvmcopy: pte should exist\u0026#34;); 16 if ((pte_to = walk(kpagetable, a, 1)) == 0) 17 panic(\u0026#34;u2kvmcopy: walk fails\u0026#34;); 18 pa = PTE2PA(*pte_from); 19 // 清除PTE_U的标记位 20 flags = (PTE_FLAGS(*pte_from) \u0026amp; (~PTE_U)); 21 *pte_to = PA2PTE(pa) | flags; 22 } 23} 在正确的地方调用这个函数，什么是正确的地方，就是pagetable改变的地方，根据提示共有四处：exec()、fork()、sbrk()、userinit() exec() 1int 2exec(char *path, char **argv) 3{ 4... 5 sp = sz; 6 stackbase = sp - PGSIZE; 7 8 // 复制 9 uvmkptcopy(pagetable, p-\u0026gt;kernel_pagetable, 0, sz); 10... 11} fork() 1int 2fork(void) 3{ 4... 5 uvmkptcopy(np-\u0026gt;pagetable, np-\u0026gt;kernel_pagetable, 0, np-\u0026gt;sz); 6 7 safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); 8... 9} sbrk()，这里要注意这个是个系统调用，真正需要添加的地方在growproc函数中 1int 2growproc(int n) 3{ 4 uint sz; 5 struct proc *p = myproc(); 6 7 sz = p-\u0026gt;sz; 8 if(n \u0026gt; 0){ 9 if (PGROUNDUP(sz + n) \u0026gt;= PLIC) 10 return -1; 11 if((sz = uvmalloc(p-\u0026gt;pagetable, sz, sz + n)) == 0) { 12 return -1; 13 } 14 // 添加复制函数 15 uvmkptcopy(p-\u0026gt;pagetable, p-\u0026gt;kernel_pagetable, sz-n, sz); 16 } else if(n \u0026lt; 0){ 17 sz = uvmdealloc(p-\u0026gt;pagetable, sz, sz + n); 18 } 19 p-\u0026gt;sz = sz; 20 return 0; 21} userinit() 1// Set up first user process. 2void 3userinit(void) 4{ 5 struct proc *p; 6 7 p = allocproc(); 8 initproc = p; 9 10 // allocate one user page and copy init\u0026#39;s instructions 11 // and data into it. 12 uvminit(p-\u0026gt;pagetable, initcode, sizeof(initcode)); 13 p-\u0026gt;sz = PGSIZE; 14 uvmkptcopy(p-\u0026gt;pagetable, p-\u0026gt;kernel_pagetable, 0, p-\u0026gt;sz); 15 16 // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. 17 p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter 18 p-\u0026gt;trapframe-\u0026gt;sp = PGSIZE; // user stack pointer 19 20 safestrcpy(p-\u0026gt;name, \u0026#34;initcode\u0026#34;, sizeof(p-\u0026gt;name)); 21 p-\u0026gt;cwd = namei(\u0026#34;/\u0026#34;); 22 23 p-\u0026gt;state = RUNNABLE; 24 25 release(\u0026amp;p-\u0026gt;lock); 26} 3.4 总结 这个实验妈的真难，part2基本不是人能想得到的，虽然基本的思路是有\u0026hellip;\u0026hellip;\n这里必须认识到所谓虚拟内存其实是假的，最开始只有freelist上可以被使用的内存，内核也得自己构建一块块内存，从0x0到0x88000000（PHYSTOP）都需要被映射，只不过0x0到0x80000000（KERNELBASE）是被映射到实际的物理设备的（可以先这样子想），后面的0x80000000到end都是被映射到数据和代码，end到PHYSTOP才是真正可以被内核和进程使用的内存，且是以页为单位被使用：\n内核映射 在全局kernel pagetable被初始化的时候trampoline和kstack都映射到free memory里面（书上图也画错了）。因此可以知道真正的程序都是运行在一块一块的页内存中的，外部通过pagetable/kernel pagetable将其组织起来，于是就有了一大块从零开始的、连续的虚拟内存的假象。下面这个图PHYSTOP错的，是0x88000000 但在这一过程中，除了程序所必须的物理内存，实际上pagetable也是被存储在内存中的（walk函数），只不过这个内存并不被程序实际使用，而是用来存储映射关系（第二级和第三级页表都是如此）。\n多级页表 其实这其中最为关键的地方是在exec函数里，加载elf文件，并用新程序覆盖原来的旧程序，最后应该还调整了PC让新程序被执行，妙啊。\n用户进程地址空间 4. Lab4 4.1 前置知识 .ld文件实际上是编译阶段要使用的，在这里会定义程序的代码段、数据段等需要存放的位置，并将一定的符号给暴露出去，例如_trampoline _entry文件是设置了很多块栈（RISC-V的栈是从上往下增长的），针对每一块CPU都设置了一页的栈，这个CPU栈的主要作用是处理内核模式下的中断和异常，这些堆栈是由start.c中初始化来的，与CPU数量一致。与kstack不同，kstack（内核栈）是用于处理进程在内核模式下的函数调用、中断和异常（即trap），数量与进程数量保持一致。因为在处理这些东西的时候仍然可能被中断，除了保存寄存器以外，也需要栈来保存函数调用的数据 caller寄存器和callee寄存器：caller寄存器一般用于保存返回地址的，用于恢复原有的调用者的正常运行；callee寄存器一般用于保存函数返回值，用于给调用者使用（如果返回值过大那有可能保存的是地址） 4.2 RISC-V assembly Which registers contain arguments to functions? For example, which register holds 13 in main\u0026rsquo;s call to printf? 这里主要理解两张图：\nRISC-V calling convention stack frame 在代码中printf函数将控制序列放到a0中，将a1，a2分别存放两个参数，这与上表18.2基本一致，另外还需要了解一点栈帧的基本知识：RISC-V栈从上至下增长，且为小端（意味着返回的地址是最低有效位的地址），fp是该栈帧的基地址，sp的栈的栈顶地址，fp到sp之间即为一个栈帧，栈帧内首先存放返回地址，再一个就是上一个fp，用于找到上一个栈帧的位置（最终目的还是定位上一个栈帧的return address），再下来就是保存一些寄存器的值用作参数，最后为保存局部变量。\n于是可以回答上述问题：1. a0 a1 a2, a2 contains 13\nWhere is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.) 这里倒没什么好讲的，主要是函数调用被编译器直接优化了。\n因此：2. Acctually compiler inline it and pre-calculate it out\nAt what address is the function printf located? 在汇编代码里也有提示：\n130: 00000097 auipc ra,0x0 #此时ra内存的就是pc=0x30 234: 600080e7 jalr 1536(ra) # 630 其中0x630就是printf函数的地址，将立即数1536与ra内的值相加即得到了跳转的目标地址，在此之前ra内的地址就是pc的地址，而pc地址是0x30，加上1536则得出目标地址为1584（0x630）。\n因此：3. 630\nWhat value is in the register ra just after the jalr to printf in main? jalr是跳转指令，以上面第二行为例，首先将ra内容加上1536作为目标跳转地址，随后jalr会将ra的值设置为当前PC+4，用于返回函数后恢复正常运行。\n因此：4. the address of current instruction plus 4\n\u0026hellip; Run the following code.\n1unsigned int i = 0x00646c72; 2printf(\u0026#34;H%x Wo%s\u0026#34;, 57616, \u0026amp;i); What is the output? Here\u0026rsquo;s an ASCII table that maps bytes to characters.The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?\n57616的16进制为0xE110，%s则代表要读取的是字符串，因此默认小端读取，在ASCII码表中，0x72代表r，0x6c代表l，0x64代表d。因此可以得到最终输出。如果是大端的话则需要改变为0x726c640000000000，因为是64位的且要保证最后一位为停止符。57616我认为不需要变化，因为只要是正确读取正确输出那就没有问题。\n因此：5. HE110 World 0x726c640000000000 no, i don\u0026rsquo;t need to\n\u0026hellip; In the following code, what is going to be printed after \u0026lsquo;y=\u0026rsquo;? (note: the answer is not a specific value.) Why does this happen?\n1printf(\u0026#34;x=%d y=%d\u0026#34;, 3); 阅读的printf汇编代码可以知道，会从a0读取输出格式，从a1-a7读取其他参数，那么在此处a1为3，y后面的值应该是a2的数据，在此情况下应该是个随机数。\n因此：6. a random number in register a2\n4.3 Backtrace Backtrace要求实现一个函数来打印从顶至下打印栈帧，还算比较简单，知道kstack是做什么用的（上面有），kstack是从上至下增长，stack frame长什么样（上面有）即可。\n首先在kernel/printf.c中定义函数backtrace： 1void backtrace(void) 2{ 3} 在kernel/defs.h中增加函数声明 kernel/riscv.h中增加以下函数用于读取寄存器fp（frame pointer），C语言里写汇编，够骚 1static inline uint64 2r_fp() 3{ 4 uint64 x; 5 asm volatile(\u0026#34;mv %0, s0\u0026#34; 6 : \u0026#34;=r\u0026#34;(x)); 7 return x; 8} 完善backtrace定义 1void backtrace(void) 2{ 3 // current fp, fp contains the top fp address 4 uint64 fp = r_fp(); 5 while(fp != PGROUNDUP(fp)) 6 { 7 printf(\u0026#34;%p\\n\u0026#34;,*((uint64*)(fp - 8))); 8 fp = *((uint64 *)(fp - 16)); 9 } 10} bbtest一下可以正常输出结果 1$ bttest 20x0000000080002ccc 30x0000000080002ba6 40x0000000080002890 并可以使用addr2line来根据地址逆向查找对应源文件位置\n1❯ addr2line -e kernel/kernel 0x0000000080002ccc 0x0000000080002ba6 0x0000000080002890 2/home/zhangzihao/xv6-labs-2020/kernel/sysproc.c:62 3/home/zhangzihao/xv6-labs-2020/kernel/syscall.c:140 4/home/zhangzihao/xv6-labs-2020/kernel/trap.c:76 这里补充一下： addr2line是一个用于逆向查找程序地址对应源代码位置的工具。它是GNU binutils工具集的一部分，可用于解析程序的地址并将其映射到源代码的行号和文件名。它常用于调试和错误排查过程中，特别是在崩溃和错误报告的分析中。通过使用addr2line，可以将程序计数器（Program Counter，PC）或地址作为输入，然后获取与该地址相关联的源代码位置信息。\n将backtrace加到panic函数里！ 小结 这个实验很简单，fp最后会回到进程对应的kstack的底部（也是地址最高点因此要PGROUNDUP），%p是带0x的地址打印，fp是栈帧的底部，但是从栈帧读取数据还是正常升序读取，因此要使用fp-8找到return address的位置，fp-16则是要找到上一个栈帧的地址。\n这里唯一需要注意的是地址与数字的加减，要记住地址的运算出来的永远是地址单元的数量，这个地址单元是根据类型而定的，而非一个字节！\n4.4 Alarm 实验要求很简单，完成两个系统调用，组合之下能够完成类似单片机设置定时中断的功能，实现思路很简单，跟着hint做就行，比page table简单1w倍。\n在Makefile中增加alarmtest.c 1UPROGS=\\ 2... 3 $U/_alarmtest\\ user/user.h中增加两个新的系统调用 1int sigalarm(int ticks, void (*handler)()); 2int sigreturn(void); user/usys.pl中增加系统调用对应的entry 1entry(\u0026#34;sigalarm\u0026#34;); 2entry(\u0026#34;sigreturn\u0026#34;); 随便挑一个内核文件增加对应的系统调用，sigalarm负责获取参数并将其记录于proc结构体里，此时sigreturn只用return 0即可，此外记得在proc.h中增加proc结构体中的字段ticks和handler 1uint64 2sys_sigalarm(void) 3{ 4 struct proc* p = myproc(); 5 // get interval and handler, store it to proc struct 6 argint(0, \u0026amp;p-\u0026gt;ticks); 7 argaddr(1, \u0026amp;p-\u0026gt;handler); 8 return 0; 9} 10uint64 11sys_sigreturn(void) 12{ 13 return 0; 14} 在syscall.c中增加对应的外部引用和标号，在此不再赘述 trap.c/usertrap中增加如下语句，从而保证能够在系统时钟中断trap返回时直接去handler函数执行 1if(which_dev == 2) 2{ 3 // the alarm is set 4 if (p-\u0026gt;ticks != 0) 5 { 6 p-\u0026gt;ticks_to_last++; 7 if (p-\u0026gt;ticks_to_last == p-\u0026gt;ticks) 8 { 9 // let user app invoke handler 10 p-\u0026gt;trapframe-\u0026gt;epc = p-\u0026gt;handler; 11 } 12 } 13 yield(); 14} 至此基本完成了test0。 7. test1和2主要的目的是恢复时钟中断trap返回时的状态，首先需要在中断trap时保存对应状态，这里我偷懒直接用trapframe结构体保存了一下\n1--- 2kernel/proc.h中proc中增加的字段 3int ticks; 4int ticks_to_last; 5uint64 handler; 6struct trapframe trapframe_for_sig; 7--- 8kernel/trap.c中usertrap中的函数 9// give up the CPU if this is a timer interrupt. 10if(which_dev == 2) 11{ 12 // the alarm is set 13 if (p-\u0026gt;ticks != 0) 14 { 15 p-\u0026gt;ticks_to_last++; 16 if (p-\u0026gt;ticks_to_last == p-\u0026gt;ticks) 17 { 18 // store the state 19 p-\u0026gt;trapframe_for_sig = *p-\u0026gt;trapframe; 20 21 // let user app invoke handler 22 p-\u0026gt;trapframe-\u0026gt;epc = p-\u0026gt;handler; 23 } 24 } 25 yield(); 26} 另外还需要在sigreturn中恢复状态 1uint64 2sys_sigreturn(void) 3{ 4 struct proc* p = myproc(); 5 *p-\u0026gt;trapframe = p-\u0026gt;trapframe_for_sig; 6// 这里不用+4的原因是该次trap是时钟中断trap，而非syscall 7// p-\u0026gt;trapframe-\u0026gt;epc += 4; 8 p-\u0026gt;ticks_to_last = 0; 9 return 0; 10} 小结： 设定定时函数时的流程为 syscall （syscall）trap 定时函数被调用的流程为 定时器中断 （定时器）trap usertrap中判断是否达到了设定时间，保存当前trapframe并通过修改trapframe中的epc来设置trap返回后的跳转 trap返回根据设定的epc设置pc，从而实现跳转效果 定时函数返回流程为 定时器函数内执行sigreturn系统调用 trap sigreturn内恢复现场并恢复trapframe！ 这个实验很简单，但很好的展示了如何设定定时函数，最后的返回更是精妙，代码量不多，但能够很好地完成任务，good！\n5. Lab5 5.1 前置知识 这个实验要做的是完成lazy allocation，还是虚拟内存相关的实验，copy-on-write，paging from disk也是一样。做这个实验之前还是要知道PTE的一些flag所代表的含义\n5.2 Eliminate allocation from sbrk() 只是lazy allocation的前置，比较简单，课上也有演示，只需要在sbrk分配内存时不真正分配，只是记录需要增加的大小\n1uint64 2sys_sbrk(void) 3{ 4... 5 myproc()-\u0026gt;sz = myproc()-\u0026gt;sz + n; 6// if(growproc(n) \u0026lt; 0) 7// return -1; 8 return addr; 9} 最终按照测试打印如下：\n1$ echo hi 2usertrap(): unexpected scause 0x000000000000000f pid=3 3 sepc=0x00000000000012ac stval=0x0000000000004008 4panic: uvmunmap: not mapped 可以简单分析一下：\nusertrap的报错是unexpected scause 0xf，实际上是因为用户程序中的指令访问了不能访问的内存，在usertrap中没有对应处理的程序，pid=3是因为第一个process是init，第二个是shell，第三个就是echo hi了（先fork再exec），sepc记录的是出错前的用户pc指令，stval是出错时的虚拟地址\npanic则是因为发生错误后需要清理内存，但是此时根据sz清理的内存实际上没有被map，因此会出错。\n5.3 Lazy allocation和Lazytests and Usertests 这两部分情况比较特殊，可以一起做了\n首先仔细分析一下，如果sbrk时不分配内存，只是记录sz的大小，此时如果进程访问未被分配的内存就会发生page fault，由trap过程中的usertrap进行处理，按照题目hints可以知道此时scause是13或15，此时需要对错误进行处理：\n获取发生错误时的虚拟地址 申请物理内存 将虚拟地址和物理内存映射起来 具体为usertrap函数中：\n1else if (r_scause() == 13 || r_scause() == 15){ 2 // page fault handler 3 uint64 va = r_stval(); 4 if (va \u0026gt; myproc()-\u0026gt;sz || va \u0026lt; PGROUNDDOWN(myproc()-\u0026gt;trapframe-\u0026gt;sp)){ 5 p-\u0026gt;killed = 1; 6 } else { 7 char* pa = kalloc(); 8 if (pa == 0) { 9 p-\u0026gt;killed = 1; 10 } else { 11 memset(pa, 0, PGSIZE); 12 va = PGROUNDDOWN(va); 13 if(mappages(myproc()-\u0026gt;pagetable, va, PGSIZE, (uint64)pa, PTE_W|PTE_X|PTE_R|PTE_U) != 0){ 14 kfree(pa); 15 p-\u0026gt;killed=1; 16 exit(-1); 17 } 18 } 19 } 20} 这里需要注意的是第四行如果内存读取到了超出最大地址和用户虚拟地址以下时是真的发生了page fault，此时需要杀掉进程，并且要处理申请不到内存和map出错的情况。\n此外在sys_sbrk函数中还需要对增加后的地址大于MAXVA或者小于0时进行处理，并且除了lazy allocation之外，在减少内存时需要立刻减少，这里直接参照growproc来写就OK\n1uint64 2sys_sbrk(void) 3{ 4 int addr; 5 int n; 6 7 if(argint(0, \u0026amp;n) \u0026lt; 0) 8 return -1; 9 addr = myproc()-\u0026gt;sz; 10 if (myproc()-\u0026gt;sz + n \u0026gt;= MAXVA || myproc()-\u0026gt;sz + n \u0026lt;= 0) 11 { 12 return addr; 13 } 14 myproc()-\u0026gt;sz = myproc()-\u0026gt;sz + n; 15 16 if (n \u0026lt; 0){ 17 uvmdealloc(myproc()-\u0026gt;pagetable, addr, myproc()-\u0026gt;sz); 18 } 19 20 return addr; 21} 除了上述的正常trap情况，如果在内核态时使用copyin和copyout函数，也同样需要进行类似usertrap的处理，因为此时不会有usertrap来正常处理page fault的情况，主要还是修改walkaddr函数，删除原有pte为0和valid flag为0的情况，增加如下处理\n1if (pte == 0 || (*pte \u0026amp; PTE_V) == 0) { 2 struct proc *p = myproc(); 3 if(va \u0026gt;= p-\u0026gt;sz || va \u0026lt; PGROUNDDOWN(p-\u0026gt;trapframe-\u0026gt;sp)) return 0; 4 5 pa = (uint64)kalloc(); 6 if (pa == 0) return 0; 7 8 if (mappages(p-\u0026gt;pagetable, va, PGSIZE, pa, PTE_W|PTE_R|PTE_U|PTE_X) != 0) { 9 kfree((void*)pa); 10 return 0; 11 } 12 return pa; 13} 最后，取消掉panic的地方即可（uvmcopy和uvmunmap）\n这个实验还有一个值得注意的地方是sh、fork和exec指令，其实sbrk是由sh中的malloc调用来执行的，目前还不是很了解这三者作用的细节，不过CSAPP好像有个shell实验可以试试看。\n6. Lab6 其实这个实验应该和Lab5的lazy allocation一起做了的，效率应该是比较高的\n6.1 问题引入 fork时会将内存复制一遍到新的进程地址空间，但实际上有时候fork后面马上跟了一个exec，这就导致之前的复制完全是没有意义的，另一方面，其实需要更改的可能只有一小部分数据，那按理来说只需要保证其他数据在真实的物理内存中只有一份，而需要更改数据存在两份（父子进程各自持有），在该种情况下，只需要更改映射就OK了\n所以COW fork需要完成的主要功能就是延迟分配和复制物理内存直到真的需要，主要任务有以下几个：\n为子进程创建pagetable，但这个pagetable的所有pte都指向父进程的实际物理内存，即存在相同的映射 将父子进程的所有PTE的flag都标记为不可写，当任何一个进程试图写的时候则会触发page fault，此时由trap来处理page faul：分配物理内存，复制新页面，更新该进程的PTE 根据提示有以下几步：\n更改uvmcopy在子进程的地址空间映射父进程的物理内存，并清除PTE的可写标志位 更改usertrap来识别page fault（类似lazy allocation），分配新的物理内存，并从共享内存中copy对应数据，将其安装到page table中，更改PTE的可写标志位 保证物理内存在没有映射后会被正确地释放，例如通过引用计数来统计引用每个物理页面的数量，kalloc分配时设置为1，fork存在共享时增加引用计数，进程从其页表中删除页面时减少引用技术。只有引用计数为0时才能够kfree掉。可以通过一个数组来追踪每个页面引用计数的数量，通过页面的物理地址/4096来索引空闲列表中的每一个物理页面（所以有多少页面呢？） 更改copyout来处理COW导致的page fault 如果COW page fault发生后没有空闲内存了，则直接杀掉进程（尝试写数据的进程），引用计数减1 6.2 Copy on Write fork步骤中，最重要的是步骤是从父进程赋值进程到子进程，其中最为重要的是uvmcopy函数，这一步需要更改的如下： 1int 2uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) 3{ 4 pte_t *pte; 5 uint64 pa, i; 6 uint flags; 7 // char *mem; 8 9 for(i = 0; i \u0026lt; sz; i += PGSIZE){ 10 if((pte = walk(old, i, 0)) == 0) 11 panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); 12 if((*pte \u0026amp; PTE_V) == 0) 13 panic(\u0026#34;uvmcopy: page not present\u0026#34;); 14 pa = PTE2PA(*pte); 15 // record at RSW to tell whether a PTE is COW mapping 16 // modify old pagetable\u0026#39;s pte to clear PET_W in parent and child 17 *pte \u0026amp;= ~PTE_W; 18 *pte |= PTE_COW; 19 flags = PTE_FLAGS(*pte); 20 21 // in cow fork, we don\u0026#39;t allocate memory for copying 22 if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){ 23 // and don\u0026#39;t free any memory 24 goto err; 25 } 26 // increase the reference count 27 acquire(\u0026amp;(mem_ref[pa/PGSIZE].lock)); 28 mem_ref[(uint64)pa/PGSIZE].cnt++; 29 release(\u0026amp;(mem_ref[pa/PGSIZE].lock)); 30 } 31 return 0; 32 33 err: 34 uvmunmap(new, 0, i / PGSIZE, 1); 35 return -1; 36} 简单总结就是先不要分配内存，保证父进程和子进程来映射同一片物理内存，并且在两者中都将pte的权限改为只读，并且用一个标志位（PTE_COW宏和PTE_V宏类似）来表示该页内存为COW内存（方便后续处理）\nCOW会导致进程或内核在访问COW内存页的时候发生page fault错误，在usertrap中需要识别该错误，并对其进行处理： 1void 2usertrap(void) 3{ 4... 5 else if (r_scause() == 15 || r_scause() == 13) { 6 // cow page fault handler 7 uint64 va = r_stval(); 8 if (cow_copy(p-\u0026gt;pagetable, va) == 0) 9 { 10 p-\u0026gt;killed = 1; 11 } 12 // va = PGROUNDDOWN(va); 13 // uint64 pa = walkaddr(p-\u0026gt;pagetable, va); 14 // pte_t *pte = walk(p-\u0026gt;pagetable, va, 0); 15 // 16 // if (get_mem_ref(pa) == 1) 17 // { 18 // // 如果某个进程访问页面，此时还是发生缺页中断，则只需要更改标志位即可 19 // // 此时意味着没有进程与其共享 20 // *pte \u0026amp;= (~PTE_COW); 21 // *pte |= (PTE_W); 22 // } else { 23 // // allocate new memory 24 // char* npa = kalloc(); 25 // // *pte = (*pte) \u0026amp; (~PTE_V); 26 // uint flags = (PTE_FLAGS(*pte) | PTE_W) \u0026amp; (~PTE_COW); 27 // 28 // if (npa == 0 || pa == 0) 29 // { 30 // p-\u0026gt;killed = 1; 31 // } 32 // // defer allocating and copying at here 33 // memmove(npa, (char *)pa, PGSIZE); 34 // // unmap the old page 35 // uvmunmap(p-\u0026gt;pagetable, PGROUNDDOWN(va), 1, 1); 36 // if (mappages(p-\u0026gt;pagetable, va, PGSIZE, (uint64)npa, flags) != 0){ 37 // kfree(npa); 38 // p-\u0026gt;killed = 1; 39 // } 40 // // decrease the count 41 // kfree((char*)PGROUNDDOWN(pa)); 42 // } 43 } 44... 45} 注释的是自己手撸的版本，可惜在赋值标志位的时候人赋值晕了，后面感觉既然在copyout要用那的确应该搞个函数来封装一下，但有点懒就偷了一个老哥的，不过换汤不换药。主要思想就是如果是只有一个引用计数的内存页，那就恢复写权限并取消COW标志位，否则就分配新内存，并取消原有映射，建立新映射，同时减少内存页的引用计数\n在内核中也可能访问物理内存，此时也需要在copyout中处理 1int 2copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) 3{ 4 ... 5 if (cow_check(pagetable, va0) != 0) 6 { 7 // pa0 must be returned 8 pa0 = cow_copy(pagetable, va0); 9 } 10 if(pa0 == 0) 11 return -1; 12 ... 13} 引用计数，通过构造自旋锁，给每个可分配的内存页都在操作系统中搞了个锁，这个步骤还是比较繁琐的（参考别人的，有一定修改） 首先是定义锁 1struct mem_ref 2{ 3 struct spinlock lock; 4 int cnt; 5}; 6 7struct mem_ref mem_ref[PHYSTOP/PGSIZE]; 随后写一个辅助函数，在线程安全的情况下获取锁 1int 2get_mem_ref(uint64 pa) 3{ 4 acquire(\u0026amp;(mem_ref[pa/PGSIZE].lock)); 5 int res = mem_ref[(uint64)pa/PGSIZE].cnt; 6 release(\u0026amp;(mem_ref[pa/PGSIZE].lock)); 7 return res; 8} 在kinit中初始化锁 1void 2kinit() 3{ 4 for(int i = 0; i \u0026lt; PHYSTOP/PGSIZE; ++i) 5 { 6 // initialize the lock 7 initlock(\u0026amp;(mem_ref[i].lock), \u0026#34;kmem_ref\u0026#34;); 8 } 9 initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); 10 freerange(end, (void*)PHYSTOP); 11} 在freerange中对引用计数进行赋值 1void 2freerange(void *pa_start, void *pa_end) 3{ 4 char *p; 5 p = (char*)PGROUNDUP((uint64)pa_start); 6 for(; p + PGSIZE \u0026lt;= (char*)pa_end; p += PGSIZE) 7 { 8 // initialize the count 9 mem_ref[(uint64)p/PGSIZE].cnt = 1; 10 kfree(p); 11 } 12} 当且仅当引用计数为0时才可以在kfree中释放内存 1void 2kfree(void *pa) 3{ 4 ... 5 // only free pa when memory reference is 0 6 uint64 pa_idx = (uint64)pa / PGSIZE; 7 acquire(\u0026amp;(mem_ref[pa_idx].lock)); 8 9 mem_ref[pa_idx].cnt--; 10 if (mem_ref[pa_idx].cnt \u0026gt; 0) 11 { 12 release(\u0026amp;(mem_ref[pa_idx].lock)); 13 return; 14 } 15 release(\u0026amp;(mem_ref[pa_idx].lock)); 16 ... 17} 在分配内存页的时候需要给引用计数赋值为1（因为此时分配的内存之前被使用过后现在值为0，不符合实际意义） 1void * 2kalloc(void) 3{ 4 ... 5 if(r) 6 { 7 uint64 pa_idx = (uint64)r / PGSIZE; 8 acquire(\u0026amp;(mem_ref[pa_idx].lock)); 9 mem_ref[pa_idx].cnt = 1; 10 release(\u0026amp;(mem_ref[pa_idx].lock)); 11 12 kmem.freelist = r-\u0026gt;next; 13 } 14 ... 15} 将cow的处理过程写成一个函数，思路就是分配、取消映射再映射，偷懒偷了别人的函数了 1uint64 2cow_copy(pagetable_t pagetable, uint64 va) 3{ 4 5 va = PGROUNDDOWN(va); 6 pte_t *pte = walk(pagetable, va, 0); 7 uint64 pa = PTE2PA(*pte); 8 9 if(get_mem_ref(pa) == 1) 10 { 11 *pte = (*pte) \u0026amp; (~PTE_COW); 12 *pte = (*pte) | (PTE_W); 13 return pa; 14 } 15 else 16 { 17 char *mem = kalloc(); 18 if(mem == 0){ 19 return 0; 20 } 21 22 memmove(mem, (char *)pa, PGSIZE); 23 *pte = (*pte) \u0026amp; (~PTE_V); 24 uint64 flag = PTE_FLAGS(*pte); 25 flag = flag | PTE_W; 26 flag = flag \u0026amp; (~PTE_COW); 27 28 if(mappages(pagetable, va, PGSIZE, (uint64)mem, flag) != 0) 29 { 30 kfree(mem); 31 return 0; 32 } 33 // decrease it! 34 kfree((char*)PGROUNDDOWN(pa)); 35 36 return (uint64)mem; 37 } 38} 另外一个辅助的函数本质上很简单，但由于复制的时候手贱把一些失败处理的删了导致测试通不过，抓耳挠腮半天才搞好，还得是测试啊妈的 1int 2cow_check(pagetable_t pagetable, uint64 va) 3{ 4 if(va \u0026gt; MAXVA) 5 return 0; 6 7 pte_t *pte = walk(pagetable, va, 0); 8 if(pte == 0) 9 { 10 printf(\u0026#34;fuck\u0026#34;);// 这个是发现usertests会测试pte为0的边界情况，妈的！ 11 return 0; 12 } 13 if(((*pte) \u0026amp; (PTE_V)) == 0) 14 return 0; 15 int res = (*pte) \u0026amp; (PTE_COW); 16 return res; 17} 总结：\n重复两次的逻辑尽量给他函数封装 一个函数太长了也要切割（其实最好是在写之前切割） 异常处理是非常必要的，在比较边界的情况下会导致出错，虽然可能功能基本实现了，但不够鲁棒！ gdb的调试不仅需要对程序足够了解，还得好好学工具的使用啊，gdb能帮很大的忙 COW的逻辑不难，主要难的是对边界情况的处理，这个实验其实最好和lazy allocation一起做 还是得研究一下测试程序，如何验证程序没有错误也是非常重要的 虽然自己写了一点，但代码能跑要感谢这个老哥 7. Lab7 7.1 Uthread 该实验目的就是添加一个用户级的thread（不支持真正的并发），栈和寄存器由thread自己保存，感觉更像协程，看懂xv6实现底层的话还是比较简单的：\n从内核中扒一下context结构体，塞thread结构体里，很类似proc结构体的操作: 1struct context { 2 uint64 ra; 3 uint64 sp; 4 5 // callee-saved 6 uint64 s0; 7 uint64 s1; 8 uint64 s2; 9 uint64 s3; 10 uint64 s4; 11 uint64 s5; 12 uint64 s6; 13 uint64 s7; 14 uint64 s8; 15 uint64 s9; 16 uint64 s10; 17 uint64 s11; 18}; 19 20struct thread { 21 char stack[STACK_SIZE]; /* the thread\u0026#39;s stack */ 22 int state; /* FREE, RUNNING, RUNNABLE */ 23 struct context context; 24}; 那么创建线程应该做些什么呢？让该线程有正确的上下文，如果该线程要被执行了，让程序能够正确的执行，在此就是指定正确的sp寄存器和ra寄存器内容 1void 2thread_create(void (*func)()) 3{ 4 struct thread *t; 5 6 for (t = all_thread; t \u0026lt; all_thread + MAX_THREAD; t++) { 7 if (t-\u0026gt;state == FREE) break; 8 } 9 // 找到了空闲线程后赋值为RUNNABLE 10 t-\u0026gt;state = RUNNABLE; 11 // YOUR CODE HERE 12 // 在sp寄存器中存储正确的栈指针位置（栈顶到栈底） 13 t-\u0026gt;context.sp = (uint64)t-\u0026gt;stack + STACK_SIZE - 1; 14 t-\u0026gt;context.ra = (uint64)func; 15} thread_switch.S，这个没啥好说的，直接扒内核代码 1thread_switch: 2 sd ra, 0(a0) 3 sd sp, 8(a0) 4 sd s0, 16(a0) 5 sd s1, 24(a0) 6 sd s2, 32(a0) 7 sd s3, 40(a0) 8 sd s4, 48(a0) 9 sd s5, 56(a0) 10 sd s6, 64(a0) 11 sd s7, 72(a0) 12 sd s8, 80(a0) 13 sd s9, 88(a0) 14 sd s10, 96(a0) 15 sd s11, 104(a0) 16 17 ld ra, 0(a1) 18 ld sp, 8(a1) 19 ld s0, 16(a1) 20 ld s1, 24(a1) 21 ld s2, 32(a1) 22 ld s3, 40(a1) 23 ld s4, 48(a1) 24 ld s5, 56(a1) 25 ld s6, 64(a1) 26 ld s7, 72(a1) 27 ld s8, 80(a1) 28 ld s9, 88(a1) 29 ld s10, 96(a1) 30 ld s11, 104(a1) 31 ret /* return to ra */ thread_schedule，这个也没啥好说的，直接加上3中的函数即可（位置都指定了） 1thread_switch((uint64)\u0026amp;t-\u0026gt;context, (uint64)\u0026amp;current_thread-\u0026gt;context); 小结：主要是理解概念，这个实验设计得很好，准确理解了xv6如何完成切换的话只需要少量的代码即可完成功能，非常不错的实验！\n7.2 Using threads 解决的核心问题：两个线程同时访问资源，应该如何保证线程安全？如果线程安全做到了，又如何保证性能？\n保证线程安全 朴素的思想就是加锁，pthread库提供了互斥锁，使用方式如下： 1pthread_mutex_t lock; // declare a lock 2pthread_mutex_init(\u0026amp;lock, NULL); // initialize the lock 3pthread_mutex_lock(\u0026amp;lock); // acquire lock 4pthread_mutex_unlock(\u0026amp;lock); // release lock 只需要在get和put函数加锁即可解决：\n1pthread_mutex_t lock; 2 3static struct entry * 4get(int key) 5{ 6 // hash操作，拼接靠链表 7 int i = key % NBUCKET; 8 9 struct entry *e = 0; 10 11 pthread_mutex_lock(\u0026amp;lock); 12 for (e = table[i]; e != 0; e = e-\u0026gt;next) 13 { 14 if (e-\u0026gt;key == key) 15 break; 16 } 17 pthread_mutex_unlock(\u0026amp;lock); 18 19 return e; 20} 21 22static void put(int key, int value) 23{ 24 int i = key % NBUCKET; 25 // is the key already present? 26 struct entry *e = 0; 27 pthread_mutex_lock(\u0026amp;lock); 28 for (e = table[i]; e != 0; e = e-\u0026gt;next) 29 { 30 if (e-\u0026gt;key == key) 31 break; 32 } 33 if (e) 34 { 35 // update the existing key. 36 e-\u0026gt;value = value; 37 } 38 else 39 { 40 // the new is new. 41 insert(key, value, \u0026amp;table[i], table[i]); 42 } 43 pthread_mutex_unlock(\u0026amp;lock); 44} 要记得完成锁的初始化，但以上的大锁又会带来新的问题，即难以使用CPU的性能，现在几乎是同步执行了，没有什么意义，因此引入了以下问题。\n如何在保证线程安全的情况下榨干CPU多核性能 这里很自然的思想是提供细粒度的锁，例如初始化多个锁，根据访问的key放到合适的位置，或者，对每一个节点都加单独的锁（很麻烦懒得做了hhh）。于是可以根据NBUCKET的数量（理解一下哈希表）来上锁： 1pthread_mutex_t lock[NBUCKET]; 2 3static struct entry * 4get(int key) 5{ 6 // hash操作，拼接靠链表 7 int i = key % NBUCKET; 8 9 struct entry *e = 0; 10 11 pthread_mutex_lock(\u0026amp;lock[i]); 12 for (e = table[i]; e != 0; e = e-\u0026gt;next) 13 { 14 if (e-\u0026gt;key == key) 15 break; 16 } 17 pthread_mutex_unlock(\u0026amp;lock[i]); 18 19 return e; 20} 21 22static void put(int key, int value) 23{ 24 int i = key % NBUCKET; 25 // is the key already present? 26 struct entry *e = 0; 27 // 根据i值决定哪把锁 28 pthread_mutex_lock(\u0026amp;lock[i]); 29 for (e = table[i]; e != 0; e = e-\u0026gt;next) 30 { 31 if (e-\u0026gt;key == key) 32 break; 33 } 34 if (e) 35 { 36 // update the existing key. 37 e-\u0026gt;value = value; 38 } 39 else 40 { 41 // the new is new. 42 insert(key, value, \u0026amp;table[i], table[i]); 43 } 44 pthread_mutex_unlock(\u0026amp;lock[i]); 45} 46 47int main(int argc, char *argv[]) 48{ 49 ... 50 // 互斥锁初始化 51 for (int i = 0; i \u0026lt; NBUCKET; i++) 52 { 53 pthread_mutex_init(\u0026amp;lock[i], NULL); 54 } 55 ... 56} 其实上面的实现还有些问题，如果线程只是读的话，没必要加锁，让其读好了，因此可以把get中的锁删了，性能可以再一次提升： concurrent thread 其实到这里还是有很多问题：\n互斥锁是什么，和自旋锁睡眠锁有什么不同，条件变量和信号量又是什么？ 参考这个\npthread提供了哪些接口，含义又是什么？ TODO\n7.3 Barrier 介绍了条件变量相关知识，利用pthread提供的条件变量机制，让所有线程都能执行完一轮后再进入下一次循环，理解条件变量即可，很类似sleep锁\n1static void 2barrier() 3{ 4 // YOUR CODE HERE 5 // 6 // Block until all threads have called barrier() and 7 // then increment bstate.round. 8 // 9 pthread_mutex_lock(\u0026amp;bstate.barrier_mutex); 10 // 记录有多少个线程到达此处 11 bstate.nthread++; 12 // 一旦线程到达数量等于总数量，则进入下一轮 13 // 否则睡眠并等待 14 if (bstate.nthread == nthread) 15 { 16 bstate.nthread = 0; 17 bstate.round++; 18 pthread_cond_broadcast(\u0026amp;bstate.barrier_cond); 19 } 20 else 21 { 22 // 释放锁 23 pthread_cond_wait(\u0026amp;bstate.barrier_cond, \u0026amp;bstate.barrier_mutex); 24 } 25 pthread_mutex_unlock(\u0026amp;bstate.barrier_mutex); 26} 核心思想是计算到达的线程有多少个，早到的就等一等，最后一个到的来完成唤醒其他线程的任务 小结：其实第一个实验还好，后面俩实验完全是pthread教程了，不写感觉也问题不大。\n8. Lab8 8.1 Memory allocator 问题来源于在分配或释放内存时，内核总是一把大锁保平安，实际上这样在多核情况下的性能并不好，那么一个有趣的思路是既然CPU们争抢一把锁，不如给每个CPU一份free list用于管理内存，同时给每个free list一把锁，来减少资源竞争，同时要完成的任务是当一个CPU的free list没空闲内存之后，要去其他CPU那里偷点过来。 那这里就会有两个基本的思路：\n在初始化的时候计算空闲内存页的数量以及CPU数量，均分一下好了（后面发现其实这种想法还是得依赖于偷） 只给第一个CPU，让其他CPU要内存的时候自己去偷 这里用第二种思路好了，正好可以妙用一手偷男机制\n基本的想法是在freepage（其实是kfree）的时候获取cpu id，把所有内存都给这个运行freepage的cpu（记得关中断），这时候基本的问题就来了，需要初始化一个和CPU数量相同的数组，并且需要初始化这些lock：\n1struct { 2 struct spinlock lock; 3 struct run *freelist; 4} kmem[NCPU]; // 根据cpu数量初始化数组 5 6void 7kinit() 8{ 9 // for 初始化所有cpu内存锁 10 for (int i = 0; i \u0026lt; NCPU; i++) { 11 // 这里第二个就算了，懒得改了 12 initlock(\u0026amp;kmem[i].lock, \u0026#34;kmem\u0026#34;); 13 } 14 // initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); 15 freerange(end, (void*)PHYSTOP); 16} 17 18void 19kfree(void *pa) 20{ 21 struct run *r; 22 23 if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) 24 panic(\u0026#34;kfree\u0026#34;); 25 26 // Fill with junk to catch dangling refs. 27 memset(pa, 1, PGSIZE); 28 29 r = (struct run*)pa; 30 31 push_off(); 32 // 获取cpuid 33 int id = cpuid(); 34 // 根据cpuid获取锁 35 // 感觉没有必要获取锁了这里，又没有并发问题 36 // 妈的不对，仔细想想steal的时候会有并发问题。。 37 acquire(\u0026amp;kmem[id].lock); 38 r-\u0026gt;next = kmem[id].freelist; 39 kmem[id].freelist = r; 40 release(\u0026amp;kmem[id].lock); 41 pop_off(); 42} 43 44void * 45kalloc(void) 46{ 47 struct run *r; 48 // 这里需要思考一下，kfree一定能snyx 49 50 push_off(); 51 int id = cpuid(); 52 53 54 acquire(\u0026amp;kmem[id].lock); 55 r = kmem[id].freelist; 56 if(r) 57 kmem[id].freelist = r-\u0026gt;next; 58 else { 59 // 如果r已经空了就会很坏很坏 60 // 只能偷点 61 for(int i = 0; i \u0026lt; NCPU; i++) { 62 // 不要重复去搞 63 if(id == i) continue; 64 acquire(\u0026amp;kmem[i].lock); 65 if (kmem[i].freelist) { 66 // 如果别人的有货，就偷一片过来 67 r = kmem[i].freelist; 68 kmem[i].freelist = kmem[i].freelist-\u0026gt;next; 69 release(\u0026amp;kmem[i].lock); 70 break; 71 } 72 release(\u0026amp;kmem[i].lock); 73 } 74 } 75 release(\u0026amp;kmem[id].lock); 76 pop_off(); 77 78 79 if(r) 80 memset((char*)r, 5, PGSIZE); // fill with junk 81 return (void*)r; 82} 8.2 Buffer cache 在现代 OS 中，所有 I/O 操作都不会直接与 disk 打交道，一般都是将 disk 中的数据拷贝到 memory 中，进程再从 memory 中进行读写。memory 中用来暂存 disk 数据的地方，叫做 Buffer cache 多个进程同时使用文件系统时，会对一把大锁（bcache.lock）产生竞争，任务就是减少对这把锁的竞争，基本思路都是把锁改小，比如让每个小的缓存都有一个锁，要求修改bget和brelse来减少对bcache.lock的竞争 按照提示看来是要用hash表了，blockno来作为key，根据提示有以下几点需要注意：\n可以用固定数量的hash表，只要能够映射就OK 在hash表内搜索或增加条目必须是原子的 之前用的双向链表的形式必须要删（看来得大改妈的），并且使用时间标记（ticks）来看看谁是最不常用的buffer，且引用计数为0，且没必要在brelse中获取bcache lock（这句没搞懂为什么） 这道题目要搞清楚每一个锁是用来保护哪些数据的，保持一致，锁保护的数据要不同\n其实问题也是非常清晰的：bcache.lock这个锁太大了，为了减少竞争只能减少锁的大小，因此这里采用上一章的一个很有意思的主题，哈希表，每个哈希表又对应一条双向链表，来保存buffer。\n修改bcache结构体，采用和上一章中相同的方式保存数据 1#define NBUCKET 13 2 3struct 4{ 5 // struct spinlock lock; // 一把大锁保平安 6 struct buf buf[NBUF]; 7 struct buf buckets[NBUCKET]; 8 struct spinlock locks[NBUCKET]; 9 10 // Linked list of all buffers, through prev/next. 11 // Sorted by how recently the buffer was used. 12 // head.next is most recent, head.prev is least. 13 // struct buf head; 14} bcache; locks保护对应的buckets\n修改binit来给锁进行初始化，并且把所有buf都挂载到buckets[0]上，让其他bucket来偷 1void binit(void) 2{ 3 struct buf *b; 4 5 // initlock(\u0026amp;bcache.lock, \u0026#34;bcache\u0026#34;); 6 for (int i = 0; i \u0026lt; NBUCKET; i++) 7 { 8 initlock(\u0026amp;bcache.locks[i], \u0026#34;bcache\u0026#34;); 9 // 先自指之后可以偷男来偷一手 10 bcache.buckets[i].prev = \u0026amp;bcache.buckets[i]; 11 bcache.buckets[i].next = \u0026amp;bcache.buckets[i]; 12 } 13 14 for (b = bcache.buf; b \u0026lt; bcache.buf + NBUF; b++) 15 { 16 // 这里是借用了原有的方法，不过先都挂在第一个bucket上 17 // 之后偷一偷分配出去 18 b-\u0026gt;next = bcache.buckets[0].next; 19 b-\u0026gt;prev = \u0026amp;bcache.buckets[0]; 20 initsleeplock(\u0026amp;b-\u0026gt;lock, \u0026#34;buffer\u0026#34;); 21 bcache.buckets[0].next-\u0026gt;prev = b; 22 bcache.buckets[0].next = b; 23 } 24} 先改brelse，这个函数的作用是释放这个block buffer的使用权，并减少其引用计数，若引用计数为0记录一下使用时间，用trap中的ticks即可 1void brelse(struct buf *b) 2{ 3 if (!holdingsleep(\u0026amp;b-\u0026gt;lock)) 4 panic(\u0026#34;brelse\u0026#34;); 5 6 releasesleep(\u0026amp;b-\u0026gt;lock); 7 8 // 这里就hash了一手，取模也是hash 9 acquire(\u0026amp;bcache.locks[b-\u0026gt;blockno % NBUCKET]); 10 b-\u0026gt;refcnt--; 11 if (b-\u0026gt;refcnt == 0) 12 { 13 b-\u0026gt;time = ticks; // 这个time是在buf.h中加的 14 } 15 release(\u0026amp;bcache.locks[b-\u0026gt;blockno % NBUCKET]); 16} 这里可以停一下想想为什么需要睡眠锁，如果多个进程都访问同一块block的buffer的话，他们的确可以找到这个buffer，但很有可能这个buffer被其他进程在用了，此时只能等待，但万万不能自旋，鬼知道别人要用多久，毕竟释放权在别人手上，只能先睡眠了。当别人使用完毕，那就调用brelse，来唤醒这些睡眠的进程，并且别人使用完了后把引用计数减1\nbpin和bunpin 这个思路就很简单，直接hash一手就ok\n1void bpin(struct buf *b) 2{ 3 acquire(\u0026amp;bcache.locks[b-\u0026gt;blockno % NBUCKET]); 4 b-\u0026gt;refcnt++; 5 release(\u0026amp;bcache.locks[b-\u0026gt;blockno % NBUCKET]); 6} 7 8void bunpin(struct buf *b) 9{ 10 acquire(\u0026amp;bcache.locks[b-\u0026gt;blockno % NBUCKET]); 11 b-\u0026gt;refcnt--; 12 release(\u0026amp;bcache.locks[b-\u0026gt;blockno % NBUCKET]); 13} bget是最麻烦的，基本思路和上一道的kalloc是相同的，先自己找，不够就向别人那里偷 1static struct buf * 2bget(uint dev, uint blockno) 3{ 4 struct buf *b; 5 6 int key = blockno % NBUCKET; 7 8 acquire(\u0026amp;bcache.locks[key]); 9 // 找找这个block是不是已经被缓存了 10 for (b = bcache.buckets[key].next; b != \u0026amp;bcache.buckets[key]; b = b-\u0026gt;next) 11 { 12 if (b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno) 13 { 14 b-\u0026gt;refcnt++; 15 release(\u0026amp;bcache.locks[key]); 16 // 这里不能简单地用自旋锁，否则会导致自旋过久，睡眠锁比较好 17 // 其他进程用完这个内存块之后，就会调用brelse，其中会wakeup这些睡眠者 18 // 谁先第一个谁就可以返回 19 acquiresleep(\u0026amp;b-\u0026gt;lock); 20 return b; 21 } 22 } 23 24 // 到这里的时候说明这个block没有被缓存，这个时候得先分配一个buffer给他 25 uint minticks = ticks; 26 struct buf *victim = 0; 27 28 // 双向链表，回到原点说明遍历完毕 29 for (b = bcache.buckets[key].next; b != \u0026amp;bcache.buckets[key]; b = b-\u0026gt;next) 30 { 31 if (b-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; b-\u0026gt;time \u0026lt;= minticks) 32 { 33 minticks = b-\u0026gt;time; 34 victim = b; 35 // 这里不返回的原因是会找不到真正最小的 36 } 37 } 38 // 此时还需要判断是否找到了这样一个空闲的且是LRU的buffer 39 if (victim) 40 { 41 // 找到了就正常覆盖整个victim 42 // 标记这个buffer是属于哪个block的 43 victim-\u0026gt;dev = dev; 44 victim-\u0026gt;blockno = blockno; 45 victim-\u0026gt;valid = 0; // 表明之前的数据是无效的 46 victim-\u0026gt;refcnt = 1; // 有一个引用计数 47 release(\u0026amp;bcache.locks[key]); 48 // 这个buffer可以直接使用 49 // 但为了和之后的brelse中的release搭配还是使用sleep 50 acquiresleep(\u0026amp;victim-\u0026gt;lock); 51 return victim; 52 } 53 else 54 { 55 // 说明这个bucket里没有空buffer了，只能从别的bucket里偷 56 for (int i = 0; i \u0026lt; NBUCKET; i++) 57 { 58 if (i == key) 59 continue; 60 acquire(\u0026amp;bcache.locks[i]); 61 minticks = ticks; 62 // 找出别的bucket里LRU的那个buffer，给他偷过来 63 for (b = bcache.buckets[i].next; b != \u0026amp;bcache.buckets[i]; b = b-\u0026gt;next) 64 { 65 if (b-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; b-\u0026gt;time \u0026lt;= minticks) 66 { 67 minticks = b-\u0026gt;time; 68 victim = b; 69 } 70 } 71 // 判断找没找到，找到继续，没找到就跳下一个bucket继续 72 if (!victim) 73 { 74 release(\u0026amp;bcache.locks[i]); 75 continue; 76 } 77 // 找到了之后就正常初始化先 78 victim-\u0026gt;dev = dev; 79 victim-\u0026gt;blockno = blockno; 80 victim-\u0026gt;valid = 0; // 表明之前的数据是无效的 81 victim-\u0026gt;refcnt = 1; // 有一个引用计数 82 83 // 下面逻辑比较绕，画个图就很好理解 84 // 从这个bucket里取出来放到自己的bucket里 85 victim-\u0026gt;next-\u0026gt;prev = victim-\u0026gt;prev; 86 victim-\u0026gt;prev-\u0026gt;next = victim-\u0026gt;next; 87 release(\u0026amp;bcache.locks[i]); 88 89 victim-\u0026gt;next = bcache.buckets[key].next; 90 bcache.buckets[key].next-\u0026gt;prev = victim; 91 bcache.buckets[key].next = victim; 92 victim-\u0026gt;prev = \u0026amp;bcache.buckets[key]; 93 release(\u0026amp;bcache.locks[key]); 94 acquiresleep(\u0026amp;victim-\u0026gt;lock); 95 return victim; 96 } 97 } 98 99 // 如果上述过程都不能获取一个正确的buffer那就报错 100 panic(\u0026#34;bget: no buffers\u0026#34;); 101} bget的任务是首先看这个buffer是不是被缓存了，如果是的话就直接返回，不是就创建新buffer，如果自己bucket中没有了，那就去别人的bucket中偷，偷的过程比较麻烦，毕竟有双向链表的操作，当然返回之前记得初始化。 更要记住哪些锁是用来保护哪些数据的：比如这里自己造的locks其实是保护这些buffer中除了data以外的数据，而buffer自己的lock是用来保护data的，保证只有一个人修改！ 在使用过程中，如果获取了自己造的locks，那就只能改除了data以外的数据，而想改data只能获取buffer自己的lock，一定要一致，保证并发程序的正确性！\n小结：总体来说这俩实验思路很相似，特别是有了lab7中已经有的hash操作之后很容易想到这些，不过实现过程中还是写G了，参考了一下这个老哥的，写的很不错。要减少并发中的竞争性只能依赖于减小锁的粒度！同时这一个实验很重要的是学会锁保护的对象是谁，要修改保护的对象必须要获取对应的锁。总结来说还是一句话，要依赖别人的经验，也要有自己的思考！\n9. Lab9 9.1 Large files 目前fs只支持256+12个blocks，一个block 1kb，因此支持的文件比较小，因此该实验要求修改模块以支持更大的文件，实验要求都描述清楚了，需要实现二层链接即其中某个direct address要改成doubly indirect address。这个倒也没多难，无非是前11个用作直接块，第12个用作一重间接块，第13个用作二重间接块\n修改NDIRECT等定义，修改inode和dinode定义，增加一些定义 1#define NDIRECT 11 2#define NINDIRECT (BSIZE / sizeof(uint)) 3#define NDUBINDIRECT (256 * NINDIRECT) 4#define MAXFILE (NDIRECT + NINDIRECT + NDUBINDIRECT) 5 6// On-disk inode structure 7struct dinode { 8 short type; // File type 9 short major; // Major device number (T_DEVICE only) 10 short minor; // Minor device number (T_DEVICE only) 11 short nlink; // Number of links to inode in file system 12 uint size; // Size of file (bytes) 13 uint addrs[NDIRECT + 2]; // Data block addresses 14}; 15 16// in-memory copy of an inode 17// 和block buffer一样的缓存机制 18struct inode { 19 uint dev; // Device number 20 uint inum; // Inode number 21 int ref; // Reference 22 // count，这里是内存中的引用计数，即在内存中引用此文件的指针数量，如果ref=0，则将其在内存中释放（写回到磁盘上） 23 struct sleeplock lock; // protects everything below here 24 int valid; // inode has been read from disk? 25 26 short type; // copy of disk inode 27 short major; 28 short minor; 29 short nlink; // 统计有多少文件目录引用到此inode以确定什么时候释放（硬盘上释放） 30 uint size; // 统计文件大小 31 uint addrs[NDIRECT + 2]; // 这个数组记录data blocks的number，毕竟inode大小是相同的 32}; 修改bmap函数，使其支持两级块的索引，这里需要注意的是一定要记得brelse，难度不大 1static uint bmap(struct inode* ip, uint bn) { 2... 3 4 bn -= NINDIRECT; 5 6 if(bn \u0026lt; NDUBINDIRECT) { 7 // 找到第一层indirect address 8 if((addr = ip-\u0026gt;addrs[NDIRECT + 1]) == 0) 9 ip-\u0026gt;addrs[NDIRECT + 1] = addr = balloc(ip-\u0026gt;dev); 10 // 读取第一层数据 11 bp = bread(ip-\u0026gt;dev, addr); 12 a = (uint*) bp-\u0026gt;data; 13 if((addr = a[bn / 256]) == 0) { 14 a[bn / 256] = addr = balloc(ip-\u0026gt;dev); 15 log_write(bp); 16 } 17 brelse(bp); 18 // 至此是最后一层 19 bp = bread(ip-\u0026gt;dev, addr); 20 a = (uint*) bp-\u0026gt;data; 21 if((addr = a[bn % 256]) == 0) { 22 a[bn % 256] = addr = balloc(ip-\u0026gt;dev); 23 log_write(bp); 24 } 25 brelse(bp); 26 return addr; 27 } 28 29 panic(\u0026#34;bmap: out of range\u0026#34;); 30} 确保itrunc释放的时候也释放了 1void itrunc(struct inode* ip) { 2... 3 if(ip-\u0026gt;addrs[NDIRECT + 1]) { 4 bp = bread(ip-\u0026gt;dev, ip-\u0026gt;addrs[NDIRECT + 1]); 5 a = (uint*) bp-\u0026gt;data; 6 for(j = 0; j \u0026lt; NINDIRECT; j++) { 7 if(a[j]) { 8 for(k = 0; k \u0026lt; NINDIRECT; k++) { 9 struct buf* bp2 = bread(ip-\u0026gt;dev, a[j]); 10 uint* a2 = (uint*) bp2-\u0026gt;data; 11 if(a2[k]) { 12 bfree(ip-\u0026gt;dev, a2[k]); 13 } 14 brelse(bp2); 15 } 16 bfree(ip-\u0026gt;dev, a[j]); 17 } 18 } 19 brelse(bp); 20 bfree(ip-\u0026gt;dev, ip-\u0026gt;addrs[NDIRECT + 1]); 21 ip-\u0026gt;addrs[NDIRECT + 1] = 0; 22 } 23 24 ip-\u0026gt;size = 0; 25 iupdate(ip); 26} 这个实验不难，仿照一级块套一层循环即可 9.2 Symbolic links xv6原生支持的是硬链接，即不同名的文件却有相同的inode，而这里要支持的是软链接，即文件中保存的真正文件的path。\n增加symlink系统调用，老套路了，这里不写 增加宏定义 1#define T_SYMLINK 4 // 软链接 2#define O_NOFOLLOW 0x100 在makefile中增加symlinktest 实现sys_symlink系统调用，这里主要思路是创建新文件，里面内容是链接的真正文件地址，使用其他函数的时候必须注意返回的inode是否带锁，否则很容易死锁，一定要注意！ 1uint64 sys_symlink(void) { 2 // input: target \u0026amp; path 3 char target[MAXPATH], path[MAXPATH]; 4 5 if(argstr(0, target, MAXPATH) \u0026lt; 0 || argstr(1, path, MAXPATH) \u0026lt; 0) 6 return -1; 7 8 begin_op(); 9 10 struct inode* ip; 11 // 搞一个inode，类型是符号链接 12 // 内容则是真正链接的文件的路径，在此处即是target 13 // 在指定目录位置创建文件并返回inode，这里直接使用create函数，方便 14 // 注意，这里返回的ip是带锁的 15 if((ip = create(path, T_SYMLINK, 0, 0)) == 0) { 16 end_op(); 17 return -1; 18 } 19 // 把真实文件path写入到此inode中 20 int res = writei(ip, 0, (uint64) target, 0, MAXPATH); 21 22 if(res != MAXPATH) { 23 end_op(); 24 return -1; 25 } 26 27 iunlockput(ip); 28 29 end_op(); 30 return 0; 31} open的时候也需要处理符号链接的情况，符号链接很容易成环，需要判断成环的情况！（注意锁的获取和释放，不要死锁！） 1uint64 sys_open(void) { 2 char path[MAXPATH]; 3 int fd, omode; 4 struct file* f; 5 struct inode* ip; 6 int n; 7 int count = 0; // 计算寻找次数 8 9 if((n = argstr(0, path, MAXPATH)) \u0026lt; 0 || argint(1, \u0026amp;omode) \u0026lt; 0) 10 return -1; 11 12 begin_op(); 13 14 if(omode \u0026amp; O_CREATE) { 15 ip = create(path, T_FILE, 0, 0); 16 if(ip == 0) { 17 end_op(); 18 return -1; 19 } 20 } else { 21 while(1) { 22 if((ip = namei(path)) == 0) { 23 end_op(); 24 return -1; 25 } 26 ilock(ip); 27 28 if(ip-\u0026gt;type == T_SYMLINK \u0026amp;\u0026amp; !(omode \u0026amp; O_NOFOLLOW)) { 29 // 递归地打开该符号链接，这里套个循环得了 30 if(count \u0026gt; 10) { 31 iunlockput(ip); 32 end_op(); 33 return -1; 34 } 35 int res; 36 res = readi(ip, 0, (uint64) path, 0, MAXPATH); 37 if(res != MAXPATH) { 38 iunlockput(ip); 39 end_op(); 40 return -1; 41 } 42 iunlockput(ip); 43 count++; 44 } else { 45 break; 46 } 47 } 48 49 if(ip-\u0026gt;type == T_DIR \u0026amp;\u0026amp; omode != O_RDONLY) { 50 iunlockput(ip); 51 end_op(); 52 return -1; 53 } 54 } 55 56... 57} 小结：这章的实验做起来感觉都有思路，被第二个实验的返回数据带不带锁坑了一把，感觉C++资源的生命周期什么的可能就是想解决这个问题。不过实话说这个还真设计的不错，对文件系统彻底了解了，回头再补一波jyy的讲解看看微软的文件系统\n10. Lab10 mmap系统调用： void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); mmap主要有俩功能：\n在进程间传输数据 将文件映射到内存中以减少传统的数据复制（磁盘-内存buffer-用户空间） 该实验只需要映射文件，假设addr为0，由内核决定真正的地址并返回，如果失败则返回0xffffffffffffffff； length来决定映射的大小，未必和文件大小相同； prot设置内存读写与执行的权限 flags决定写的内容需不需要被写回文件 fd是指定文件描述符 offset假设为0 在该实验中只要求实现文件映射内存，猜测可能是先标记一下，之后访问就page fault然后一页页地从文件中读到内存映射部分（user space）而非buffer cache中\n另一个需要实现的是munmap\n1int munmap(void *addr, size_t length); 清理指定范围的map，有点free的意思了，如果有脏数据并且有正确的flags就回写到文件，并解除指定位置的映射。成功返回0，失败返回-1\n也就是说这个实验是要添加这俩系统调用了。但还不是很懂mmap的作用，直接看了(这个人的)[https://zhuanlan.zhihu.com/p/458326109]。 传统的xv6系统调用需要经过以下几步：\nread系统调用-\u0026gt;usertrap内核处理-\u0026gt;sys_read-\u0026gt;fileread-\u0026gt;readi，由readi把数据从硬盘搬到内核缓存再搬到用户空间。在此过程中每次的读写都需要read、write经历上述系统调用过程。mmap就直接把文件内容搬到了用户空间，可以直接操作，免得每次都要经过系统调用这几步。\n添加mmap和munmap系统调用，添加mmaptest到makfile，老操作了，这里不写 mmap把真正的加载推迟到了访问时，很类似lazy allocation、copy on write的操作，在实现之前需要想想，如果要在访问时再加载，则必须保存mmap的相关信息，在此处构造了一个结构体来保存这些信息：virtual memory area（vma），来保存虚拟内存分布相关信息 proc.h：\n1#define VMASIZE 16 2struct vma { 3 int used; 4 uint64 addr; 5 int length; 6 int prot; 7 int flags; 8 int fd; 9 int offset; 10 struct file *file; 11}; 12 13// Per-process state 14struct proc { 15 struct spinlock lock; 16 17 // p-\u0026gt;lock must be held when using these: 18 enum procstate state; // Process state 19 struct proc *parent; // Parent process 20 void *chan; // If non-zero, sleeping on chan 21 int killed; // If non-zero, have been killed 22 int xstate; // Exit status to be returned to parent\u0026#39;s wait 23 int pid; // Process ID 24 25 // these are private to the process, so p-\u0026gt;lock need not be held. 26 uint64 kstack; // Virtual address of kernel stack 27 uint64 sz; // Size of process memory (bytes) 28 pagetable_t pagetable; // User page table 29 struct trapframe *trapframe; // data page for trampoline.S 30 struct context context; // swtch() here to run process 31 struct file *ofile[NOFILE]; // Open files 32 struct inode *cwd; // Current directory 33 char name[16]; // Process name (debugging) 34 35 struct vma vma[VMASIZE]; 36}; 这里vma数组的大小按照题目hints给16即可\nmmap实现就很简单了，只需要记录这些信息按兵不动，找一个没被用过的vma位置来保存自己的数据 1uint64 sys_mmap(void) { 2 uint64 error = 0xffffffffffffffff; 3 4 uint64 addr; 5 int length, prot, flags, fd, offset; 6 struct file *file; // 根据fd获取 7 8 if (argaddr(0, \u0026amp;addr) || argint(1, \u0026amp;length) || argint(2, \u0026amp;prot) || argint(3, \u0026amp;flags) || argfd(4, \u0026amp;fd, \u0026amp;file) || 9 argint(5, \u0026amp;offset)) { 10 return error; 11 } 12 13 // 这三种情况同时出现必错 14 if (!file-\u0026gt;writable \u0026amp;\u0026amp; (prot \u0026amp; PROT_WRITE) \u0026amp;\u0026amp; flags == MAP_SHARED) { 15 return error; 16 } 17 18 length = PGROUNDUP(length); 19 20 struct proc* p = myproc(); 21 // 剩余可用空间不足 22 if ((p-\u0026gt;sz + length) \u0026gt; MAXVA) { 23 return error; 24 } 25 26 // 从进程PCB可用VMA中找个空位置插进去 27 // 这里不直接分配 28 for (int i = 0; i \u0026lt; VMASIZE; i++) { 29 if (p-\u0026gt;vma[i].used == 0) { 30 p-\u0026gt;vma[i].used = 1; 31 p-\u0026gt;vma[i].addr = p-\u0026gt;sz; // 不管给的地址是什么，都从现有位置开始增长 32 p-\u0026gt;vma[i].length = length; 33 p-\u0026gt;vma[i].prot = prot; 34 p-\u0026gt;vma[i].flags = flags; 35 p-\u0026gt;vma[i].fd = fd; 36 p-\u0026gt;vma[i].file = file; 37 p-\u0026gt;vma[i].offset = offset; 38 // pin一下这个file 39 filedup(file); 40 p-\u0026gt;sz += length; 41 return p-\u0026gt;vma[i].addr; 42 } 43 } 44 return error; 45} 同时munmap也有思路，无非是unmap一部分或整体，找到对应的vma对其addr增加即可 1uint64 sys_munmap(void) { 2 uint64 addr; 3 int length; 4 5 struct proc *p = myproc(); 6 struct vma *vma = 0; 7 8 if (argaddr(0, \u0026amp;addr) || argint(1, \u0026amp;length)) { 9 return -1; 10 } 11 addr = PGROUNDDOWN(addr); 12 length = PGROUNDUP(length); 13 14 // 找到对应的vma 15 for (int i = 0; i \u0026lt; VMASIZE; i++) { 16 if (addr \u0026gt;= p-\u0026gt;vma[i].addr || addr \u0026lt; (p-\u0026gt;vma[i].addr + p-\u0026gt;vma[i].length)) { 17 vma = \u0026amp;p-\u0026gt;vma[i]; 18 break; 19 } 20 } 21 if (vma == 0) return -1; 22 // 这里很有趣，并没有全部都给删了，而是只删了申请的部分 23 if (vma-\u0026gt;addr == addr) { 24 vma-\u0026gt;addr += length; 25 vma-\u0026gt;length -= length; 26 if (vma-\u0026gt;flags \u0026amp; MAP_SHARED) 27 filewrite(vma-\u0026gt;file, addr, length); 28 uvmunmap(p-\u0026gt;pagetable, addr, length / PGSIZE, 1); 29 if (vma-\u0026gt;length == 0) { 30 fileclose(vma-\u0026gt;file); 31 vma-\u0026gt;used = 0; 32 } 33 } 34 return 0; 35} 接下来就类似lazy allocation，cow等步骤了，在usertrap中增加page fault处理逻辑，主要思路就是根据发生错误的地址，找到对应vma，进而分配内存，从文件中读取数据并复制到新内存，mappages时给正确的标志位： 1void 2usertrap(void) 3{ 4... 5 } else if((which_dev = devintr()) != 0){ 6 // ok 7 } else if(r_scause() == 13 || r_scause() == 15) { 8 uint64 va = r_stval(); // 发生page fault的位置 9 10 if (va \u0026gt;= p-\u0026gt;sz || va \u0026gt; MAXVA || PGROUNDUP(va) == PGROUNDDOWN(p-\u0026gt;trapframe-\u0026gt;sp)) { 11 p-\u0026gt;killed = 1; 12 } else { 13 // 正常的处理步骤 14 struct vma *vma = 0; 15 for (int i = 0; i \u0026lt; VMASIZE; i++) { 16 // 找到这个地址对应的vma，即找到file 17 if (p-\u0026gt;vma[i].used == 1 \u0026amp;\u0026amp; va \u0026gt;= p-\u0026gt;vma[i].addr \u0026amp;\u0026amp; (va \u0026lt; p-\u0026gt;vma[i].addr + p-\u0026gt;vma[i].length)) { 18 vma = \u0026amp;p-\u0026gt;vma[i]; 19 break; 20 } 21 } 22 23 if (vma) { 24 // 地址的页面底部 25 va = PGROUNDDOWN(va); 26 27 uint64 offset = va - vma-\u0026gt;addr; 28 29 uint64 mem = (uint64)kalloc(); 30 if (mem == 0) { 31 p-\u0026gt;killed = 1; 32 } else { 33 memset((void *)mem, 0, PGSIZE); 34 // 把数据从文件中读取出来，感觉很怪，不还是一样吗 35 ilock(vma-\u0026gt;file-\u0026gt;ip); 36 readi(vma-\u0026gt;file-\u0026gt;ip, 0, mem, offset, PGSIZE); 37 iunlock(vma-\u0026gt;file-\u0026gt;ip); 38 // 设置权限位 39 int flag = PTE_U; 40 if (vma-\u0026gt;prot \u0026amp; PROT_READ) flag |= PTE_R; 41 if (vma-\u0026gt;prot \u0026amp; PROT_WRITE) flag |= PTE_W; 42 if (vma-\u0026gt;prot \u0026amp; PROT_EXEC) flag |= PTE_X; 43 44 if (mappages(p-\u0026gt;pagetable, va, PGSIZE, mem, flag) != 0) { 45 kfree((void *)mem); 46 p-\u0026gt;killed = 1; 47 } 48 } 49 } 50 51 } 52 } else { 53 printf(\u0026#34;usertrap(): unexpected scause %p pid=%d\\n\u0026#34;, r_scause(), p-\u0026gt;pid); 54 printf(\u0026#34; sepc=%p stval=%p\\n\u0026#34;, r_sepc(), r_stval()); 55 p-\u0026gt;killed = 1; 56 } 57... 58} 与lazy allocation和cow类似，在uvmunmap和uvmcopy两个函数中删除panic，因为此时页面尚未被加载到page table，倒也不能直接panic 1void 2uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) 3{ 4 uint64 a; 5 pte_t *pte; 6 7 if((va % PGSIZE) != 0) 8 panic(\u0026#34;uvmunmap: not aligned\u0026#34;); 9 10 for(a = va; a \u0026lt; va + npages*PGSIZE; a += PGSIZE){ 11 if((pte = walk(pagetable, a, 0)) == 0) 12 panic(\u0026#34;uvmunmap: walk\u0026#34;); 13 if((*pte \u0026amp; PTE_V) == 0) 14 continue; 15 // panic(\u0026#34;uvmunmap: not mapped\u0026#34;); 16 if(PTE_FLAGS(*pte) == PTE_V) 17 panic(\u0026#34;uvmunmap: not a leaf\u0026#34;); 18 if(do_free){ 19 uint64 pa = PTE2PA(*pte); 20 kfree((void*)pa); 21 } 22 *pte = 0; 23 } 24} 25 26int 27uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) 28{ 29 pte_t *pte; 30 uint64 pa, i; 31 uint flags; 32 char *mem; 33 34 for(i = 0; i \u0026lt; sz; i += PGSIZE){ 35 if((pte = walk(old, i, 0)) == 0) 36 panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); 37 if((*pte \u0026amp; PTE_V) == 0) 38 continue; 39 // panic(\u0026#34;uvmcopy: page not present\u0026#34;); 40 pa = PTE2PA(*pte); 41 flags = PTE_FLAGS(*pte); 42 if((mem = kalloc()) == 0) 43 goto err; 44 memmove(mem, (char*)pa, PGSIZE); 45 if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){ 46 kfree(mem); 47 goto err; 48 } 49 } 50 return 0; 51 52 err: 53 uvmunmap(new, 0, i / PGSIZE, 1); 54 return -1; 55} 在fork和exit系统调用部分也需要处理，fork的时候要复制vma数组，exit的时候要回写数据到文件（如果有标志位的话） 1int 2fork(void) 3{ 4... 5 np-\u0026gt;state = RUNNABLE; 6 7 for(i = 0; i \u0026lt; VMASIZE; i++) { 8 if(p-\u0026gt;vma[i].used){ 9 memmove(\u0026amp;(np-\u0026gt;vma[i]), \u0026amp;(p-\u0026gt;vma[i]), sizeof(p-\u0026gt;vma[i])); 10 filedup(p-\u0026gt;vma[i].file); 11 } 12 } 13 14 release(\u0026amp;np-\u0026gt;lock); 15 16 return pid; 17} 18 19void 20exit(int status) 21{ 22 struct proc *p = myproc(); 23 24 if(p == initproc) 25 panic(\u0026#34;init exiting\u0026#34;); 26 27 // Close all open files. 28 for(int fd = 0; fd \u0026lt; NOFILE; fd++){ 29 if(p-\u0026gt;ofile[fd]){ 30 struct file *f = p-\u0026gt;ofile[fd]; 31 fileclose(f); 32 p-\u0026gt;ofile[fd] = 0; 33 } 34 } 35 36 for(int i = 0; i \u0026lt; VMASIZE; i++) { 37 if(p-\u0026gt;vma[i].used) { 38 if(p-\u0026gt;vma[i].flags \u0026amp; MAP_SHARED) 39 filewrite(p-\u0026gt;vma[i].file, p-\u0026gt;vma[i].addr, p-\u0026gt;vma[i].length); 40 fileclose(p-\u0026gt;vma[i].file); 41 uvmunmap(p-\u0026gt;pagetable, p-\u0026gt;vma[i].addr, p-\u0026gt;vma[i].length/PGSIZE, 1); 42 p-\u0026gt;vma[i].used = 0; 43 } 44 } 45... 46} 小结：之前mmap完全理解不了，这下感觉也是虚拟内存的妙用，虚拟化才是真正的神啊。这样一想，java调用dll的jna可能也是相同的操作，把库加载，然后俩进程执行，中间部分数据共享。头文件该加还是得加，不然会出错，如果可以的话可以用sh脚本来统一添加头文件和#pragma once。brk分配的内存只能等高位内存释放后才能释放，mmap分配的内存可以单独释放，当然释放是以页为单位。\n11. Lab11 给e1000网卡加驱动，说实话本来以为是让人了解一下网络，没想到只是写个驱动，大概理解怎么写，但实在不想看这个datasheet了。\n首先需要了解，网卡硬件收到数据后会通过DMA把数据放到内存指定位置，而发送也是通过到指定位置找数据发送，这些位置以及控制的指令都是通过读写内存映射的寄存器来做到的。以发送为例：\n1struct mbuf { 2 struct mbuf *next; // the next mbuf in the chain 3 char *head; // the current start position of the buffer 4 unsigned int len; // the length of the buffer 5 // 分配的页面是4kb，但这里只能用上mbuf大小的内存，2kb多一点，因此在此处head指向的就是buf中可用内存！ 6 char buf[MBUF_SIZE]; // the backing store 7}; 8 9// [E1000 3.2.3] 10struct rx_desc 11{ 12 // 存储接收数据的地址 13 uint64 addr; /* Address of the descriptor\u0026#39;s data buffer */ 14 // 已经使用的长度 15 uint16 length; /* Length of data DMAed into data buffer */ 16 // 校验和 17 uint16 csum; /* Packet checksum */ 18 uint8 status; /* Descriptor status */ 19 uint8 errors; /* Descriptor Errors */ 20 uint16 special; 21}; 22 23 24#define RX_RING_SIZE 16 25// 循环数组用以存储真正要放数据的空间的地址 26static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16))); 27// 注意到上面需要一个空间，这里多半就是了 28static struct mbuf *rx_mbufs[RX_RING_SIZE]; 其中mbuf是真正存储数据的地方，rxdesc只不过是保存这些地址。根据hints和网上代码，这个lab的做法如下：\ne1000_transmit 1int 2e1000_transmit(struct mbuf *m) 3{ 4 // 5 // Your code here. 6 // 7 // the mbuf contains an ethernet frame; program it into 8 // the TX descriptor ring so that the e1000 sends it. Stash 9 // a pointer so that it can be freed after sending. 10 // 11 12 // 真正存数据的位置是mbuf，这里需要做的是把存了需要发送的数据的mbuf的地址放入空闲的发送位置里 13 // 而运行完毕之后就需要释放该mbuf 14 15 acquire(\u0026amp;e1000_lock); 16 17 uint32 r_index = regs[E1000_TDT]; 18 19 // 检查是否满了 20 if ((tx_ring[r_index].status \u0026amp; E1000_TXD_STAT_DD) == 0) { 21 release(\u0026amp;e1000_lock); 22 return -1; 23 } 24 25 // 已经发送的可以释放了 26 if (tx_mbufs[r_index]) { 27 mbuffree(tx_mbufs[r_index]); 28 } 29 30 // 原有的位置填上正确的需要传输的mbuf 31 tx_ring[r_index].addr = (uint64) m-\u0026gt;head; 32 tx_ring[r_index].length = (uint64) m-\u0026gt;len; 33 tx_ring[r_index].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP; 34 35 tx_mbufs[r_index] = m; 36 regs[E1000_TDT] = (regs[E1000_TDT] + 1) % TX_RING_SIZE; 37 release(\u0026amp;e1000_lock); 38 return 0; 39} e1000_recv 1static void 2e1000_recv(void) 3{ 4 // 5 // Your code here. 6 // 7 // Check for packets that have arrived from the e1000 8 // Create and deliver an mbuf for each packet (using net_rx()). 9 // 10 11 // 网卡会用DMA的方式把数据放到合适的位置 12 // 之后产生中断，进入该函数，该函数主要负责采用net_rx处理mbuf的数据 13 // 要记得分配新的mbuf，原来的mbuf应该是给net_rx使用了 14 while (1) { 15 // 获取下标 16 uint32 r_index = (regs[E1000_RDT] + 1) % RX_RING_SIZE; 17 18 if ((rx_ring[r_index].status \u0026amp; E1000_RXD_STAT_DD) == 0) { 19 return; 20 } 21 rx_mbufs[r_index]-\u0026gt;len = (uint32)rx_ring[r_index].length; 22 if (rx_mbufs[r_index]) { 23 // 此时该指针的负责人被转向net_rx，由其负责释放，同时也避免了复制 24 net_rx(rx_mbufs[r_index]); 25 } 26 rx_mbufs[r_index] = mbufalloc(0); 27 rx_ring[r_index].addr = (uint64)rx_mbufs[r_index]-\u0026gt;head; 28 rx_ring[r_index].status = 0; 29 regs[E1000_RDT] = r_index; 30 } 31} 这个实验感觉出的一般，重点并非网络而是驱动的编写，重点我倒是掌握了，懒得去读驱动手册了\n参考 网友网站1 csdiy的介绍 中文翻译 课本翻译 课程中文翻译 环境搭建、调试以及代码跳转 MIT 6.S081 2020 操作系统 实验环境搭配详解及问题处理 Fall2020/6.S081-如何在 QEMU 中使用 gdb MIT 6.S081: Lab 0 搭建环境 MIT 6.S081 xv6调试不完全指北 - KatyuMarisa - 博客园 MIT 6S081 qemu-gdb debug调试新手指南!!!! 从零开始使用Vscode调试XV6 在vscode上完美调试xv6指南 6.S081的调试和VSCode环境配置 课程官网以及视频 6.S081 / Fall 2020 Lecture 6 - Isolation \u0026amp;amp; System Call Entry_Exit 中文版_哔哩哔哩_bilibili 老外xv6代码详解 代码导读中文视频 阿苏EEer，也是这个UP主的，更正经一点 cactus-agenda-c84.notion.site，对课本有详细的解释 ","date":"2023-07-10T20:08:56+08:00","permalink":"https://o-a-p.github.io/post/os/6.s081-lab/","section":"post","tags":["/img/6.S081/6.S081.png"],"title":"6.S081：实验"},{"categories":["Tool","GDB","Linux"],"contents":"1. GDB是什么 GDB（GNU Debugger）是GNU项目的调试器，支持Ada、Assembly、C、C++、D、Fortran、Go、Objective-C、OpenCL、Modula-2、Pascal、Rust\ngbdinit和gdb中的python什么的还得了解一下\n可以写个.gdbinit来使得每次使用gdb都自动打开图形模式，可以执行gdb -q来省略开头的提醒信息！\n另外gdb还支持反向调试，具体得先record一下，指令前面要加reverse-\n2. GDB基础指令 2.1 断点设置 使用GDB的前提是程序带有调试信息（gcc -g），如果没有调试信息使用gdb则会显示：\n如果程序已经运行且还想调试的话，可以采用ps -ef | grep 进程名的方式来找到已运行程序的pid，进而使用attach pid的方式进行调试：gdb a.out -p pid 如果程序已经运行且没有调试信息还想调试的话，可以保持代码不动，生成一版带有调试信息的程序，再进gdb，后使用file 可执行程序名的方式进行读写，然后使用attach pid进行链接调试 直接gdb 可执行程序 调试core文件 一般来讲第一个命令都可以直接使用首字母，且gdb命令行有自动补全，常见断点命令如下: 2.2 查看变量/信息 主动通过print来查看变量： 如果想查看内存可以通过examine来查看： 如果希望程序中断时自动显示某个变量的值可以使用display命令，相关命令如下： 堆栈/线程/栈帧/变量设置： 打印各种信息： 2.3 单步调试 2.4 多进程调试 2.5 多线程调试 2.6 查看源码 2.7 TUI界面 Ctrl L可以刷新错位的GDB窗口\n3. 杂 coredump 当进程崩溃时，操作系统会把进程当前的所有内存和寄存器状态信息保存到core dump文件中。Core dump file 是一个二进制文件，需要配合 debug info 来赋予其含义。GDB 可以读取 core dump 文件，协助分析进程崩溃的瞬间发生了什么。\n生成coredump文件必须要设置：ulimit -c unlimited\n生成的文件所在目录可以通过：cat /proc/sys/kernel/core_pattern查看\n最终调试还是需要原可执行程序参与：gdb ddd /mnt/wslg/dumps/core.ddd\n程序会停在崩溃的前一行！\n参考：1\nABI ABI代表应用程序二进制接口（Application Binary Interface）。ABI定义了编译器、链接器和操作系统之间的接口规范，确保不同的软件组件可以相互操作和交互。\nABI在计算机系统中起到了关键的作用。它规定了二进制程序的格式、函数调用约定、寄存器使用、内存布局等方面的规范。通过遵循共同的ABI，不同的软件模块可以在同一操作系统上运行，并且可以相互调用和交换数据，而不需要关注底层实现的细节。\n不同的操作系统和处理器架构通常有不同的ABI。例如，x86架构的ABI与ARM架构的ABI可能存在差异。同样，不同的操作系统也可以有自己的ABI，如Windows的ABI与Linux的ABI可能有所不同。\n使用一致的ABI有助于跨平台开发、库的兼容性和代码的可移植性。它还为操作系统提供了与应用程序进行交互的标准接口，包括系统调用、异常处理和动态链接等。\n执行外部命令 在 GDB（GNU 调试器）中，!是一个前缀，用于在GDB命令中执行外部命令。当你在GDB的命令行中输入 ! 后跟一个外部命令，GDB 将会在操作系统的命令行执行该命令，并将其输出显示在 GDB 的命令行界面上。\n这个功能使得你可以在调试过程中方便地执行一些操作系统级别的命令，如查看文件列表、运行其他程序等。通过在 GDB 中执行外部命令，你可以在不离开调试环境的情况下获取更多的信息或执行其他必要的操作。\n例如可以先使用i inferiors查看进程信息，再通过gdb中!pmap pid显示一个进程的内存使用情况，包括代码段、数据段、堆、栈以及共享库等的映射情况。\n5. 参考网站 GDB调试指南 💻【Linux】GDB 入门笔记 GDB手册 GitBook – Knowledge management simplified CS107 GDB教程 ","date":"2023-07-08T15:27:53+08:00","permalink":"https://o-a-p.github.io/post/tool/gdb/","section":"post","tags":null,"title":"GDB命令"},{"categories":["Test","Shortcode"],"contents":"1. 画廊效果的两种实现 1.1 实现1 \u003c!DOCTYPE html\u003e Google 1.2 实现2 6 callingConvention callingStack ecall interrupt kmemmap mit pagetable scheduling syscall threadConcurrent userspace xargs 2. 豆瓣卡片 2.1 neodb 支持neodb和原生豆瓣（已失效，依赖第三方api的果然不长久）\n2.2 手动添加信息，目前有用，依赖豆瓣 H庄园的午餐 9.1 一个英国版的红玫瑰与白玫瑰的故事。年轻美丽的埃莉诺•卡莱尔平静地站在被告席上。她是H庄园女主人韦尔曼太太的侄女，被控谋杀了她的情敌——H庄园门房的女儿玛丽•杰拉德。证据确凿：埃莉诺准备了那份致命午餐，也只有她拥有作案动机和时机。然而，在那个充满敌意的法庭上，只有一个人依然认为埃莉诺直到被证明有罪之前是清白的。赫尔克里•波洛挡在了埃莉诺和绞刑台之间…… book 3. spotify 4. 图片轮播 5. 站内链接 6.S081：实验 日期: 2023-07-10 \u0026nbsp; 标签: #OS\u0026nbsp; #6.S081\u0026nbsp; 实验捏 6. ppt/pdf \u003c!DOCTYPE HTML\u003e 7. bilibili \u003c!DOCTYPE HTML\u003e 8. youtube 9. 文字排版 文字居左\n文字居中\n文字居右\n10. quote 十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\n😂😎🎨🥪🛴💥\n十里青山远，潮平路带沙。数声啼鸟怨年华。又是凄凉时候，在天涯。白露收残月，清风散晓霞。绿杨堤畔问荷花。记得年时沽酒，那人家。\nTo see a world in a grain of sand. And a heaven in a wild flower. Hold infinity in the palm of your hand. And eternity in an hour.\n十里青山远，潮平路带沙\n数声啼鸟怨年华\n又是凄凉时候，在天涯\n白露收残月，清风散晓霞\n绿杨堤畔问荷花\n记得年时沽酒，那人家\n11. 折叠 折叠方式1 1printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;);printf(\u0026#34;123\u0026#34;); 2printf(\u0026#34;123\u0026#34;); 3printf(\u0026#34;123\u0026#34;); 4printf(\u0026#34;123\u0026#34;); 👉 折叠方式2 这是折叠的内容～\n这是折叠的内容～\n同样是MD文档，不受影响\n12. 图片排版 并列排版 13. 分割线 END End end 描述文字 不是end或者bye则显示普通文字 BYE Bye bye 14. 表情包 这玩意感觉和图片一样的 15. 图片带标题 实现方式1 大小\n大小\n大小\n实现方式2 head 16. Live Photo \u003c!DOCTYPE html\u003e Live Photo Example 17. 单行图文混排 文字 文字\n18. 时间轴 2024-10-15 标签 时间轴 这是一个时间轴 2024-10-16 标签 时间轴 这是一个时间轴 19. 热力图 20. 友链 OAP 我自己 21. mermaid graph LR A[Square Rect] -- Link text --\u003e B((Circle)) A --\u003e C(Round Rect) B --\u003e D{Rhombus} C --\u003e D 参考 老哥1\n老哥2\n老哥3\n老哥4\n老哥5\n老哥6\n老哥7\n老哥8\n老哥9\n老哥10\n老哥11\n老哥12\n老哥13\n老哥14\n","date":"1970-01-01T21:47:11+08:00","permalink":"https://o-a-p.github.io/post/test/shortcodestest/","section":"post","tags":null,"title":"短代码测试"},{"categories":["Test"],"contents":"H1 H2 H3 H4 H5 H6 This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nParagraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don’t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren’t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Code block with backticks 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3 \u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; 5 \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; 6 \u0026lt;/head\u0026gt; 7 \u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; 9 \u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; Code block indented with four spaces 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; Code block with Hugo’s internal highlight shortcode 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese 单词解释 term definition 图片 Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike’s talk during Gopherfest, November 18, 2015.\n","date":"1970-01-01T18:58:11+08:00","permalink":"https://o-a-p.github.io/post/test/syntaxtest/","section":"post","tags":null,"title":"Markdown Syntax Guide"},{"categories":null,"contents":" MySQL优化相关 常用设计模式 去掉博客对外部资源的依赖 👉 Done C++内存序 增加livephoto短代码 增加分割线对bye的支持 增加单行图文混排短代码 修复豆瓣图文api失效问题 修复主页卡片在浅色模式不可见问题 优化主页卡片样式 优化Todo页面checkbox样式 ","date":"0001-01-01T00:00:00Z","permalink":"https://o-a-p.github.io/todo/","section":"","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://o-a-p.github.io/goods/","section":"","tags":null,"title":"我的好东西"},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://o-a-p.github.io/photo/","section":"","tags":null,"title":"我的相册"}]